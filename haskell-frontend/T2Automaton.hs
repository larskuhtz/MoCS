{- *** MOCS-COPYRIGHT-NOTICE-BEGIN ***
 -
 - This copyright notice is auto-generated by ./add-copyright-notice.
 - Additional copyright notices must be added below the last line of this notice.
 -
 - MoCS (https://lewis.cs.uni-saarland.de/tools/mocs/): "haskell-frontend/T2Automaton.hs".
 - The content of this file is copyright of Saarland University -
 - Copyright (C) 2009 Saarland University, Reactive Systems Group, Lars Kuhtz <kuhtz@cs.uni-sb.de>.
 -
 - This file is part of MoCS (https://lewis.cs.uni-saarland.de/tools/mocs/).
 -
 - License: three-clause BSD style license.
 - The license text can be found in the file LICENSE.
 -
 - *** MOCS-COPYRIGHT-NOTICE-END *** -}

module T2Automaton where

import Control.Monad.State
import qualified Data.Map as M

-- import Debug.Trace
import Foreign.C.Types

import CExpr
import CAut

import Ordinal
import PSLFragment
import qualified Temporal as T
import qualified Regular as R
import qualified Propositional as P

xxx a b = do { x <- a; lift $ b x}
yyy a b c = do { x <- a; y <- b; lift $ c x y}

-------------------------------------------------------------------------------
-- | Maps propositions to the corresponding port-numbers of the automaton
type PropTable = M.Map String CLong

-------------------------------------------------------------------------------
-- p2aut
p2aut :: P.Formula -> StateT (AutCtxPtr,PropTable) IO AutPtr
p2aut (P.Var s) = do 
  (ctx,table) <- get
  let (ntable,p) = query table s
  put (ctx,ntable)
  lift $ propAut ctx [p]

p2aut (P.Const b) = do { ctx <- gets fst; lift $ constAut ctx b}
p2aut (P.Or a b) = yyy (p2aut a) (p2aut b) orAut
p2aut (P.And a b) = yyy (p2aut a) (p2aut b) andAut
p2aut (P.Negate a) = p2aut a `xxx` dualAut

-------------------------------------------------------------------------------
-- r2aut
query table e = maybe (M.insert e (int2c $ M.size table) table, (int2c $ M.size table))
                      (\x -> (table, x))
                      (M.lookup e table)

r2aut :: R.Expression P.Formula -> StateT (AutCtxPtr,PropTable) IO AutPtr
r2aut (R.Prop e) = p2aut e

-- Conc
r2aut (f `R.Conc` g) = yyy (r2aut f) (r2aut g) concAut
r2aut (f `R.OConc` g) = yyy (r2aut f) (r2aut g) oconcAut

-- Kleene Closure
r2aut (R.Kleene Infty f) = xxx (r2aut f) kleeneAut

-- Finite bound: reduce to Conc
r2aut (R.Kleene (Finite 0) _) = r2aut R.mkEpsilon
r2aut (R.Kleene b r) = r2aut (r `R.Conc` (R.mkKleene (b-1) r))

-- Union
r2aut (f `R.Union` g) = yyy (r2aut f) (r2aut g) unionAut

-- Epsilon
r2aut R.Epsilon = do { ctx <- gets fst; lift $ emptyAut ctx}

{--
-- Intersection
r2aut (R.Intersection r0 r1) = liftM2 autIntersection (r2aut r0) (r2aut r1) >>= mkUnique
--}

r2aut x = error $ "not implemented yet: " ++ (show x)

-- -----------------------------------------------------------------------------
-- | Build an alternating automaton from 'T.Formula' over 'R.Expression'

createAut :: T.Formula R.Expression P.Formula -> IO (AutCtxPtr,PropTable,AutPtr)
createAut f = do 
  ctx <- newAutCtx
  (a,(x,t)) <- runStateT (t2aut f) (ctx,M.empty)
  return (x,t,a)

createAutWithTable :: PropTable -> T.Formula R.Expression P.Formula -> IO (AutCtxPtr,PropTable,AutPtr)
createAutWithTable table f = do
  ctx <- newAutCtx
  (a,(x,t)) <- runStateT (t2aut f) (ctx,table)
  return (x,t,a)

createAutWithCtx :: AutCtxPtr -> T.Formula R.Expression P.Formula -> IO (AutCtxPtr,PropTable,AutPtr)
createAutWithCtx ctx f = do 
  (a,(x,t)) <- runStateT (t2aut f) (ctx,M.empty)
  return (x,t,a)

createAutWithCtxAndTable :: AutCtxPtr -> PropTable -> T.Formula R.Expression P.Formula -> IO (AutCtxPtr,PropTable,AutPtr)
createAutWithCtxAndTable ctx table f = do 
  (a,(x,t)) <- runStateT (t2aut f) (ctx,table)
  return (x,t,a)

-- A StateT Monad over IO. Passes around the context and a PropTabel
t2aut :: T.Formula R.Expression P.Formula -> StateT (AutCtxPtr,PropTable) IO AutPtr

t2aut f = -- trace ("t2aut: " ++ toString f) $ 
          t2aut' f

-- Prop (strong by default) -- FIXME does not happen for now, there are SEREs!
t2aut' (T.Prop p) = p2aut p

-- r2aut implements tight modeling. Hence we need to append (true)*
-- Reg (default semantics as implemented by r2aut is strong!)
--t2aut' (T.StrongReg r) = r2aut (r `R.mkConc` R.mkKleene Infty (R.mkProp (P.mkConst True)))
t2aut' (T.StrongReg r) = r2aut (r `R.mkConc` tail_aut)
--t2aut' (T.StrongReg r) = r2aut r
  where
  tail_aut = either (error "") (id) (parse "epsilon|true")

-- WeakReg
--t2aut' (T.WeakReg r) = r2aut (r `R.mkConc` R.mkKleene Infty (R.mkProp (P.mkConst True))) `xxx` weakAut
t2aut' (T.WeakReg r) = r2aut (r `R.mkConc` tail_aut) `xxx` weakAut
--t2aut' (T.WeakReg r) = r2aut r `xxx` weakAut
  where
  tail_aut = either (error "") (id) (parse "epsilon|true")

-- Negate
t2aut' (T.Negate f) = t2aut f `xxx` dualAut
-- And
t2aut' (f `T.And` g) = yyy (t2aut f) (t2aut g) andAut
-- Or
t2aut' (f `T.Or` g) = yyy (t2aut f) (t2aut g) orAut

-- Build alternating automaton for 'T.Next'
t2aut' (T.Next Infty f) = t2aut f `xxx` nextAut
t2aut' (T.Next b f) = t2aut f `xxx` bnextAut (int2c (finite b))
t2aut' (T.WNext Infty f) = t2aut f `xxx` wnextAut
t2aut' (T.WNext b f) = t2aut f `xxx` wbnextAut (int2c (finite b))
  
-- Globally
t2aut' (T.Globally (Finite 0) f) = t2aut f
t2aut' (T.Globally Infty f) = t2aut f `xxx` gAut
t2aut' (T.Globally b f) = t2aut f `xxx` bgAut (int2c (finite b))

-- strong Globally (TODO)
t2aut' (T.SGlobally Infty _) = error "Monitoring strong unbounded globally is meaningless. If you want to replace it by 'false' enable this in PSLFragment.hs."
-- t2aut' (T.SGlobally Infty f) = p2aut (P.mkConst False)
t2aut' (T.SGlobally b f) = t2aut f `xxx` sbgAut (int2c (finite b))

-- Eventually
t2aut' (T.Eventually (Finite 0) f) = t2aut f
t2aut' (T.Eventually Infty f) = t2aut f `xxx` fAut
t2aut' (T.Eventually b f) = t2aut f `xxx` bfAut (int2c (finite b))

-- weak Eventually (TODO)
t2aut' (T.WEventually Infty _) = error "Monitoring weak unbounded eventually is meaningless. If you want to replace it by 'true' enable this in PSLFragment.hs."
-- t2aut' (T.WEventually Infty f) = p2aut (P.mkConst True)
t2aut' (T.WEventually b f) = t2aut f `xxx` wbfAut (int2c (finite b))

-- Until
t2aut' (T.Until (Finite 0) _ g) = t2aut g
t2aut' (T.Until Infty f g) = yyy (t2aut f) (t2aut g) untilAut
t2aut' (T.Until b f g) = yyy (t2aut f) (t2aut g) (buntilAut (int2c (finite b)))

-- Waitfor (TODO)
t2aut' (T.Waitfor (Finite 0) _ g) = t2aut g
t2aut' (T.Waitfor Infty f g) = yyy (t2aut f) (t2aut g) waitforAut
t2aut' (T.Waitfor b f g) = yyy (t2aut f) (t2aut g) (bwaitforAut (int2c (finite b)))

-- Release
t2aut' (T.Release (Finite 0) _ g) = t2aut g
t2aut' (T.Release Infty f g) = yyy (t2aut f) (t2aut g) releaseAut
t2aut' (T.Release b f g) = yyy (t2aut f) (t2aut g) (breleaseAut (int2c (finite b)))

-- strong Release (TODO)
t2aut' (T.SRelease (Finite 0) _ g) = t2aut g
t2aut' (T.SRelease Infty f g) = yyy (t2aut f) (t2aut g) sreleaseAut
t2aut' (T.SRelease b f g) = yyy (t2aut f) (t2aut g) (sbreleaseAut (int2c (finite b)))

-- Build alternating automaton for 'T.Abort'
t2aut' (T.Abort f b) = yyy (t2aut f) (p2aut b) abortAut 
{--
  a <- t2aut f
  st <- newUnique
  let delta' = M.map (\x -> (x `mkAnd` (NProp b)) `mkOr` ((State st) `mkAnd` (Prop b))) (delta a) 
  let delta'' = M.insert st (Const False) (delta')
  return $ a { states = S.insert st (states a)
             , final = S.insert st (final a)
             , delta = delta'
             }
--}

-- Build alternating automaton for 'T.SImplies'
-- NOTE:  Use strong semantics (and tight?) for r (as implemented by r2aut)
-- Reason: the context can switch to weak either through negation (in this
--         case the dualization does the right thing) or by some weak temporal
--         operator (in this case the acceptance does not to be adjusted recursively).
t2aut' (T.SImplies r f) = yyy (r2aut r) (t2aut f) simpliesAut

{--
t2aut' (T.SImplies r f) = do
  ar <- r2aut r
  dar <- mkUnique $ autDual ar
  af <- t2aut f
  let delta' = (delta af) `M.union` (delta dar) `M.union` (M.map (mapExprCond (const (initial af)) (isFinal ar)) (delta ar))
  return $ A { props = (props ar) `S.union` (props dar) `S.union` (props af)
             , states = (states ar) `S.union` (states dar) `S.union` (states af)
             , initial = (initial ar) `mkOr` (initial dar)
             , final = (final af) `S.union` (final dar)
             , delta = delta'
             }
--}

-- t2aut' x = error $ "not implemented yet: " ++ (show x)
