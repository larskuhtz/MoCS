{- *** MOCS-COPYRIGHT-NOTICE-BEGIN ***
 -
 - This copyright notice is auto-generated by ./add-copyright-notice.
 - Additional copyright notices must be added below the last line of this notice.
 -
 - MoCS (https://lewis.cs.uni-saarland.de/tools/mocs/): "haskell-frontend/PSL.hs".
 - The content of this file is copyright of Saarland University -
 - Copyright (C) 2009 Saarland University, Reactive Systems Group, Lars Kuhtz.
 -
 - This file is part of MoCS (https://lewis.cs.uni-saarland.de/tools/mocs/).
 -
 - License: three-clause BSD style license.
 - The license text can be found in the file LICENSE.
 -
 - *** MOCS-COPYRIGHT-NOTICE-END *** -}

{-# LANGUAGE IncoherentInstances, ExistentialQuantification, TypeSynonymInstances, Rank2Types #-}
module PSL where

import Text.ParserCombinators.Parsec

import Data.List

import qualified Propositional as P
import qualified Regular as R
import qualified Temporal as T
import PSLLexer
import ToString
import Ordinal
import qualified PSLFragment as PSL

--------------------------------------------------------------------------------
type PSL = T.Formula R.Expression P.Formula
type RegularExpression = R.Expression P.Formula
type Proposition = P.Formula

-- data TR = forall a. TempReg a => TR a -- needed for implementation of pslSubf
class PSL.PSLFragment a => TempReg a where
  mkProp :: Proposition -> a
  mkTemporal :: a -> PSL
  isConstant :: a -> Bool
  -- formulaFoldCond x :: (a -> [TR a]) -> (a -> [a] -> a) -> a -> x
--  pslSubf :: (a -> [TR])
instance TempReg PSL where
  mkProp = T.mkProp
  mkTemporal = id
  isConstant (T.Prop (P.Const _)) = True
  isConstant _ = False
  -- formualFoldCond subfFunc func f = func f (map (formulaFoldCond func) (subfFunc f))
--  pslSubf (T.WeakReg r) = [TR r]
--  pslSubf (T.StrongReg r) = [TR r]
--  pslSubf (T.SImplies r f) = [TR r,TR f]
--  pslSubf f = map TR (PSL.subf f)
instance TempReg RegularExpression where
  mkProp = R.mkProp
  mkTemporal = T.mkWeakReg
  isConstant (R.Prop (P.Const _)) = True
  isConstant _ = False
--  pslSubf f = map TR (PSL.subf f)
  -- formualFoldCond subfFunc func f = func f (map (formulaFoldCond func) (subfFunc f))
--
--  separate f = formulaFoldCond subfFunc func f
--    where 
--    subfFunc f = if (isFinite.PSL.horizon f) then [] else pslSubf f
--    func f [] = sep f
--    func (TR (T.WeakReg f)) l = ((T.mkWeakReg f), l)
--    func (TR (T.StrongReg f)) l = ((T.mkStrongReg f), l)
--    func f l = ((PSL.constr f), (map fst l)), concatMap snd l)
--    sep x = if isConstant x then  (x,[]) else ((mkProp.P.mkVar.toString) x,[mkTemporal x])

--  grec rf f = let l = map rf (PSL.subf f) in ((PSL.constr f) (map fst l), concatMap snd l)
--  rec (T.Prop f) = error "A proposition must not have infinit horizon."
--  rec (T.WeakReg f) = un rseparate T.mkWeakReg f
--  rec (T.StrongReg f) = un rseparate T.mkStrongReg f
--  rec (T.SImplies r f) = let (a0,b0) = rseparate r; (a1,b1) = separate' crit f in (T.mkSImplies a0 a1, b0 ++ b1)
--  rec f = grec (separate' crit) f
--  un f c s = let (a,b) = f s in (c a, b)

--------------------------------------------------------------------------------
-- computes the separation formulas of f
-- returns a list of separation formulas, the formula f where each separation
-- formula is replaced by a fresh variable, and a mapping (or hash table?) between these
-- variable and the separation formulas.
-- TODO: for now the mapping is implicit through the nameing of the fresh variables 
-- (these are generated by use of toString)

separate f = separate' (isFinite.PSL.horizon) f
separate' :: (forall a. PSL.PSLFragment a => a -> Bool) -> PSL -> (PSL,[PSL])
separate' crit f = if crit f then sep f else rec f
  where
  -- TODO provide generic PSL recursion scheme/ fold operator instead
  grec rf f = let l = map rf (PSL.subf f) in ((PSL.constr f) (map fst l), concatMap snd l)
  rec (T.Prop _) = error "A proposition must not have infinit horizon."
  rec (T.WeakReg f) = un rseparate T.mkWeakReg f
  rec (T.StrongReg f) = un rseparate T.mkStrongReg f
  rec (T.SImplies r f) = let (a0,b0) = rseparate r; (a1,b1) = separate' crit f in (T.mkSImplies a0 a1, b0 ++ b1)
  rec f = grec (separate' crit) f
  un f c s = let (a,b) = f s in (c a, b)

  rseparate r = if crit r  then sep r else grec rseparate r

  -- This is safe, since equality propagates to toString (as it produces 
  -- a term that is equivalent to the parsed expression
  -- Constants get propagated
  sep x = if isConstant x then  (x,[]) else ((mkProp.P.mkVar.toString) x,[mkTemporal x])

altSeparate f = separate' (null.PSL.subf) f

freshProp :: PSL -> PSL
freshProp f = T.mkProp $ P.mkVar $ freshString (map toString $ allVars f)
  where
  freshString list = head (seps \\ list)
  seps = map (((++) "sep") . show) [0..] 

allVars f = tAllVars f
  where
  tAllVars (T.Prop x) = P.allVars x
  tAllVars (T.WeakReg x) = rAllVars x
  tAllVars (T.StrongReg x) = rAllVars x
  tAllVars f = concatMap  tAllVars $ T.allRegProps f

  rAllProps (R.Prop x) = P.allVars x
  rAllProps _ = error "rAllProps must be called only on Propositions"

  rAllVars r = concatMap rAllProps $ R.allProps r

            

--------------------------------------------------------------------------------
parsePSL s = parse pslParser "" s

pslParser :: Parser PSL
pslParser = do
  whiteSpace
  x <- T.parser
  eof
  return x

