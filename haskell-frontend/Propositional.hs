{- *** MOCS-COPYRIGHT-NOTICE-BEGIN ***
 -
 - This copyright notice is auto-generated by ./add-copyright-notice.
 - Additional copyright notices must be added below the last line of this notice.
 -
 - MoCS (https://lewis.cs.uni-saarland.de/tools/mocs/): "haskell-frontend/Propositional.hs".
 - The content of this file is copyright of Saarland University -
 - Copyright (C) 2009 Saarland University, Reactive Systems Group, Lars Kuhtz <kuhtz@cs.uni-sb.de>.
 -
 - This file is part of MoCS (https://lewis.cs.uni-saarland.de/tools/mocs/).
 -
 - License: three-clause BSD style license.
 - The license text can be found in the file LICENSE.
 -
 - *** MOCS-COPYRIGHT-NOTICE-END *** -}

module Propositional where

import qualified Text.ParserCombinators.Parsec as P
import Text.ParserCombinators.Parsec.Expr

import Data.List

import ToString
import PSLLexer
import PSLFragment

data Formula 
  = Var String
  | Const Bool
  | Or Formula Formula
  | And Formula Formula
  | Negate Formula
  deriving (Eq,Ord,Show)


mkVar s = Var s
mkConst b = Const b
mkAnd x y | x < y =  And x y
          | otherwise = And y x
mkOr x y  | x < y = Or x y
          | otherwise = Or y x
mkNegate x = Negate x

instance ToString Formula where
  toString e = case e of
    (Var s) -> s
    (Const True) -> "true"
    (Const False) -> "false"
    (And x y) -> bin "^" x y
    (Or x y) -> bin "+" x y
    (Negate x) -> un "-" x
    where
    un o f = o ++ toString f
    bin o f g = "(" ++ toString f ++ " " ++ o ++ " " ++ toString g ++ ")"

instance PSLFragment Formula where
  horizon _ = 0
  dual = dual'
  subf = subf'
  subfmap = rec
  parser = formula
  constant = mkConst
  constr = error "not implemented yet"


-------------------------------------------------------------------------------
-- usefull for variable substitution

-- subformulas as list
subf' (Negate f) = [f]
subf' (Or f g) = [f, g]
subf' (And f g) = [f, g]
subf' _ = []

allVars :: Formula -> [Formula]
allVars h = case h of
  (Const _) -> []
  (Var _)   -> return h
  _         -> subf h >>= allVars 

-- Usefull for mutual recursive defintions (see e.g. pushNegations)
rec a (Negate f) = mkNegate (a f)
rec a (Or f g) = mkOr (a f) (a g)
rec a (And f g) = mkAnd (a f) (a g)
rec _ f = f

-------------------------------------------------------------------------------
-- Dualities
dual' (Var s) = mkNegate (mkVar s)
dual' (Const True) = mkConst False
dual' (Const False) = mkConst True

dual' (Negate f) = f
dual' (Or f g) = mkAnd (dual' f) (dual' g)
dual' (And f g) = mkOr (dual' f) (dual' g)

-------------------------------------------------------------------------------
-- Push negations to state level

pushNegations (Negate f) = dual f
pushNegations f = rec pushNegations f

-------------------------------------------------------------------------------
-- misc
isBinary f = length (subf f) == 2

allEq [] = True
allEq [_] = True
allEq (a:b:t) = (a == b) && (allEq (b:t))

-------------------------------------------------------------------------------
-- Formula-Parser

-- formula :: CharParser st Formula
formula =
  buildExpressionParser table expr
  P.<?> "Formula: formula"

expr = parens formula
  P.<|> (identifier >>= return . mkVar)
  P.<|> (reserved "true" >> return (mkConst True))
  P.<|> (reserved "false" >> return (mkConst False))
  P.<?> "Formula: atomic expression"


-- table :: OperatorTable Char () Formula
table = [ [prefix "-" mkNegate]
        , [binary "^" mkAnd AssocLeft, binary "+" mkOr AssocLeft]
        ]

binary name fun assoc  = Infix (reservedOp name >> return fun) assoc
prefix name fun        = Prefix (reservedOp name >> return fun)

