{- *** MOCS-COPYRIGHT-NOTICE-BEGIN ***
 -
 - This copyright notice is auto-generated by ./add-copyright-notice.
 - Additional copyright notices must be added below the last line of this notice.
 -
 - MoCS (https://lewis.cs.uni-saarland.de/tools/mocs/): "haskell-frontend/Temporal.hs".
 - The content of this file is copyright of Saarland University -
 - Copyright (C) 2009 Saarland University, Reactive Systems Group, Lars Kuhtz.
 -
 - This file is part of MoCS (https://lewis.cs.uni-saarland.de/tools/mocs/).
 -
 - License: three-clause BSD style license.
 - The license text can be found in the file LICENSE.
 -
 - *** MOCS-COPYRIGHT-NOTICE-END *** -}

{-# LANGUAGE FlexibleContexts #-}
{- Logic:
 - * Prop
 - * WeakReg    (weak)
 - * StrongReg  (strong)
 -
 - * Negate
 - * And
 - * Or
 - 
 - * Next     (weak)
 - * BNext     (weak)
 - * WNext    (strong)
 - * WBNext    (strong)
 -
 - * Until    (strong)  (sugar)
 - * Waitfor  (weak)    (sugar)
 - * BUntil   (strong)
 - * BWaitfor (weak)
 -
 - * Release   (weak)    (sugar)
 - * SRelease  (strong)  (sugar)
 - * BRelease  (weak)
 - * SBRelease (strong)
 -
 - * Globally   (weak)    (sugar)
 - * BGlobally  (weak)
 - * SBGlobally (strong)
 -
 - * Eventually   (strong) (sugar)
 - * BEventually  (strong)
 - * WBEventually (weak)
 -
 - * Abort
 - * Simplies
 -}

module Temporal 
  ( Formula(..)
  , mkProp
  , mkWeakReg
  , mkStrongReg
  
  , mkNegate
  , mkAnd
  , mkOr

  , mkNext
  , mkBNext
  , mkWNext
  , mkWBNext
  
  , mkUntil
  , mkWaitfor
  , mkBUntil
  , mkBWaitfor
  
  , mkRelease
  , mkSRelease
  , mkBRelease
  , mkSBRelease

  , mkGlobally
  , mkBGlobally
  , mkSBGlobally

  , mkEventually
  , mkBEventually
  , mkWBEventually

  , mkAbort
  , mkSImplies

  , mkImplies
  , mkEquiv
  
  , formula
  , parser
  , pushNegations
  , simplify
  --, unfoldLevelF
  --, unfoldF
  --, unfoldAllF
  --, unfoldBoundedF
  , pushNextRec
  , allSubf
  , allLeaves
  , dual
  , rec
  , toString
  , allRegProps
  , allRegs
  , allProps
  , isBounded
  )

where

import qualified Text.ParserCombinators.Parsec as P
import Text.ParserCombinators.Parsec.Expr

import Data.Typeable
import Data.List

import PSLLexer
import ToString
import PSLFragment
import Ordinal

-- usualy reg should be defined upon prop as well.
data Formula reg prop 
  = Prop prop
  | WeakReg (reg prop)
  | StrongReg (reg prop)

  | Negate (Formula reg prop)
  | And (Formula reg prop) (Formula reg prop)
  | Or (Formula reg prop) (Formula reg prop)

  | Next Bound (Formula reg prop)
  | WNext Bound (Formula reg prop)

  | Until Bound (Formula reg prop) (Formula reg prop)
  | Waitfor Bound (Formula reg prop) (Formula reg prop)
  | Release Bound (Formula reg prop) (Formula reg prop)
  | SRelease Bound (Formula reg prop) (Formula reg prop)

  | Globally Bound (Formula reg prop)
  | SGlobally Bound (Formula reg prop)
  | Eventually Bound (Formula reg prop)
  | WEventually Bound (Formula reg prop)

  | Abort (Formula reg prop) prop
  | SImplies (reg prop) (Formula reg prop)
  deriving (Eq, Ord,Show)

instance (Typeable (reg prop), Typeable prop) => Typeable (Formula reg prop) where
  typeOf f = mkTyConApp (mkTyCon "Formula") [typeOf f]

instance (PSLFragment (reg prop), PSLFragment prop) => PSLFragment (Formula reg prop) where
  horizon = horizon'
  dual = dual'
  subfmap = rec
  subf = subf'
  parser = formula
  constant = mkProp . constant
  simplify = simplify'
  constr = constr'

-- horizon
horizon' (Prop p) = horizon p
horizon' (WeakReg r) = horizon r
horizon' (StrongReg r) = horizon r

horizon' (Negate f) = horizon' f
horizon' (And f g) = max (horizon' f) (horizon' g)
horizon' (Or f g) = max (horizon' f) (horizon' g)

horizon' (Next b f) = horizon' f + b
horizon' (WNext b f) = horizon' f + b

horizon' (Until b f g) = max (b + horizon' f) ((b - 1) + horizon' g)
horizon' (Waitfor b f g) = max (b + horizon' f) ((b - 1) + horizon' g)
horizon' (Release b f g) = max (b + horizon' f) (b + horizon' g)
horizon' (SRelease b f g) = max (b + horizon' f) (b + horizon' g)

horizon' (Globally b f) = horizon' f + b
horizon' (SGlobally b f) = horizon' f + b
horizon' (Eventually b f) = horizon' f + b
horizon' (WEventually b f) = horizon' f + b

horizon' (Abort f _) = horizon' f
horizon' (SImplies r f) = (horizon r) + (horizon' f) - 1

-- generator
mkProp e = Prop e
mkWeakReg s = WeakReg s
mkStrongReg b = StrongReg b

mkNegate x = Negate x
mkAnd x y | x < y =  And x y
          | otherwise = And y x
mkOr x y  | x < y = Or x y
          | otherwise = Or y x

mkNext x = Next 1 x
mkWNext x = WNext 1 x

mkBNext b x = Next b x
mkWBNext b x = WNext b x

mkUntil x y = Until Infty x y
mkWaitfor x y = Waitfor Infty x y
mkBUntil b x y = Until b x y
mkBWaitfor b x y = Waitfor b x y

mkRelease x y = Release Infty x y
mkSRelease x y = SRelease Infty x y
mkBRelease b x y = Release b x y
mkSBRelease b x y = SRelease b x y

mkGlobally x = Globally Infty x
mkBGlobally b x = Globally b x
mkSBGlobally b x = SGlobally b x

mkEventually x = Eventually Infty x
mkBEventually b x = Eventually b x
mkWBEventually b x = WEventually b x

mkAbort f e = Abort f e
mkSImplies r f = SImplies r f

-- suguar
mkImplies x y = mkOr (mkNegate x) y
mkEquiv x y = mkAnd (mkImplies x y) (mkImplies y x)

-------------------------------------------------------------------------------
-- Note: we maintain arguments of associative operators (and, or) ordered.
-- Alternatively we could have coded this into the instanciation of EQ.
-- The ordered approach is probably more efficient. It Requires, however, that
-- The mk-Constructors are always used to create new Formulas.


-------------------------------------------------------------------------------
-- constr
constr' f = case f of
    (Prop _) -> const f
    (StrongReg _) -> const f
    (WeakReg _) -> const f
    (Negate _) -> un mkNegate
    (And _ _) -> bin mkAnd
    (Or _ _) -> bin mkOr
    (Next b _) -> bun mkBNext b
    (WNext b _) -> bun mkWBNext b
    (Until b _ _) -> bbin mkBUntil b
    (Waitfor b _ _) -> bbin mkBWaitfor b
    (Release b _ _) -> bbin mkBRelease b
    (SRelease b _ _) -> bbin mkSBRelease b
    (Globally b _) -> bun mkBGlobally b
    (SGlobally b _) -> bun mkSBGlobally b
    (Eventually b _) -> bun mkBEventually b
    (WEventually b _) -> bun mkWBEventually b
    (Abort _ e) -> (\(x:_) -> mkAbort x e)
    (SImplies r _) -> (\(x:_) -> mkSImplies r x)
    where
    un c = \(x:_) -> c x
    bun c b = \(x:_) -> c b x
    bin c = \(l:r:_) -> c l r
    bbin c b = \(l:r:_) -> c b l r

-------------------------------------------------------------------------------
-- show
-- Currently prints out format used by parser
-- TODO set parenthesis only where needed
instance (Show prop, Show (reg prop), ToString (reg prop), ToString prop) => ToString (Formula reg prop) where
  toString f = case f of
    (Prop e) -> toString e
    (StrongReg r) -> un "\\strong" r
    (WeakReg r) -> toString r

    (Negate f) -> un "\\not" f
    (And f g) -> bin "\\and" f g
    (Or f g) -> bin "\\or" f g

    (Next Infty f) -> un "\\N" f
    (WNext Infty f) -> un "\\wN" f
    (Next b f) -> bbin "\\BN" b f
    (WNext b f) -> bbin "\\wBN" b f

    (Until Infty f g) -> bin "\\U" f g
    (Waitfor Infty f g) -> bin "\\W" f g
    (Until b f g) -> tri "\\BU" b f g
    (Waitfor b f g) -> tri "\\BW" b f g

    (Release Infty f g) -> bin "\\R" f g
    (SRelease Infty f g) -> bin "\\sR" f g
    (Release b f g) -> tri "\\BR" b f g
    (SRelease b f g) -> tri "\\sBR" b f g

    (Globally Infty f) -> un "\\G" f
    (Globally b f) -> bbin "\\BG" b f
    (SGlobally b f) -> bbin "\\sBG" b f
    
    (Eventually Infty f) -> un "\\F" f
    (Eventually b f) -> bbin "\\BF" b f
    (WEventually b f) -> bbin "\\wBF" b f

    (Abort f e) -> bin "\\abort" f e
    (SImplies r f) -> bin "\\simplies" r f

    where
    un o f = o ++ " " ++ toString f
    bin o f g = "(" ++ toString f ++ " " ++ o ++ " " ++ toString g ++ ")"
    bbin o b f = o ++ " " ++ p b ++ " " ++ toString f
    tri o b f g = "(" ++ toString f ++ " " ++ o ++ " " ++ p b ++ " " ++ toString g ++ ")"
    p b = toString b

-------------------------------------------------------------------------------
-- usefull for variable substitution

-- subformulas as list
subf' (Negate f) = [f]
subf' (Or f g) = [f, g]
subf' (And f g) = [f, g]

subf' (Next _ f) = [f]
subf' (WNext _ f) = [f]

subf' (Globally _ f) = [f]
subf' (SGlobally _ f) = [f]
subf' (Eventually _ f) = [f]
subf' (WEventually _ f) = [f]

subf' (Until _ f g) = [f, g]
subf' (Waitfor _ f g) = [f, g]
subf' (Release _ f g) = [f, g]
subf' (SRelease _ f g) = [f, g]

subf' (Abort f _) = [f]
subf' (SImplies _ f) = [f]

subf' _ = []

allRegs :: Formula reg prop -> [Formula reg prop]
allRegs h = case h of
  (WeakReg _)   -> return h
  (StrongReg _) -> return h
  _             -> subf' h >>= allRegs 

allProps :: Formula reg prop -> [Formula reg prop]
allProps h = case h of
  (Prop _) -> return h
  _        -> subf' h >>= allProps

allRegProps :: Formula reg prop -> [Formula reg prop]
allRegProps h = case h of
  (WeakReg _)   -> return h
  (StrongReg _) -> return h
  (Prop _)      -> return h
  _             -> subf' h >>= allRegProps


-- Usefull for mutual recursive defintions (see e.g. pushNegations)
rec :: (Ord (reg prop), Ord prop, PSLFragment (Formula reg prop)) => 
       (Formula reg prop -> Formula reg prop) -> Formula reg prop -> Formula reg prop
rec a f = if atomic f then f else (constr f) (map a (subf f))

-------------------------------------------------------------------------------
-- Dualities
dual' (Prop f) = mkNegate (mkProp f)
dual' (WeakReg f) = mkNegate (mkWeakReg f)
dual' (StrongReg f) = mkNegate (mkStrongReg f)

dual' (Negate f) = f
dual' (Or f g) = mkAnd (dual f) (dual g)
dual' (And f g) = mkOr (dual f) (dual g)

dual' (Next b f) = mkWBNext b (dual f)
dual' (WNext b f) = mkBNext b (dual f)

dual' (Globally b f) = mkBEventually b (dual f)
dual' (SGlobally b f) = mkWBEventually b (dual f)
dual' (Eventually b f) = mkBGlobally b (dual f)
dual' (WEventually b f) = mkSBGlobally b (dual f)

dual' (Until b f g) = mkBRelease b (dual f) (dual g)
dual' (Waitfor b f g) = mkSBRelease b (dual f) (dual g)
dual' (Release b f g) = mkBUntil b (dual f) (dual g)
dual' (SRelease b f g) = mkBWaitfor b (dual f) (dual g)

dual' (Abort f e) = mkNegate (mkAbort f e)
dual' (SImplies r f) = (mkNegate (StrongReg r)) `mkOr` (r `mkSImplies` (dual f))

-------------------------------------------------------------------------------
-- Push negations to state level

pushNegations (Negate f) = dual f
pushNegations f = rec pushNegations f

-------------------------------------------------------------------------------
-- Push Next-Operators
pushNext h = case h of
  (Next b (Negate f)) -> mkNegate $ mkWBNext b f
  (WNext b (Negate f)) -> mkNegate $ mkBNext b f
  (Next b f) -> rec (mkBNext b) f
  (WNext b f) -> rec (mkWBNext b) f
  _ -> h

pushNextRec h = bottomUpRec p' h
  where
  p' h = case h of { (Next b f) -> topDownRec pushNext (mkBNext b f); _ -> h}

-------------------------------------------------------------------------------
-- misc
isBinary f = length (subf f) == 2

isBounded (Next u _) = isFinite u
isBounded (WNext u _) = isFinite u
isBounded (Globally u _) = isFinite u
isBounded (SGlobally u _) = isFinite u
isBounded (Eventually u _) = isFinite u
isBounded (WEventually u _) = isFinite u
isBounded (Until u _ _) = isFinite u
isBounded (Waitfor u _ _) = isFinite u
isBounded (Release u _ _) = isFinite u
isBounded (SRelease u _ _) = isFinite u
isBounded _ = True

allEq [] = True
allEq [_] = True
allEq (a:b:t) = (a == b) && (allEq (b:t))

-------------------------------------------------------------------------------
-- Simplification rules

simplify' f = bottomUpRec (simple5 . simple4 . simple3 . simple2 . simple1) f

simple1 (Abort f e) = mkAbort f e
simple1 (SImplies r f) = mkSImplies r f
simple1 h = if isBinary h && allEq (subf h) then head (subf h) else h

-- (Constants are not part of PSL any more)
simple2 = id

{-
-- Dualities for binary operators
simple3 (Or f g)          | isDual f g = mkConst True
                          | otherwise = mkOr f g
simple3 (And f g)         | isDual f g =  mkConst False
                          | otherwise = mkAnd f g
simple3 (BUntil b f g)    | isDual f g = mkBUntil b (Const True) g
                          | otherwise = mkBUntil b f g
simple3 (BRelease b f g)  | isDual f g = mkConst True
                          | otherwise = mkBRelease b f g
simple3 (WBUntil b f g)   | isDual f g = mkWBUntil b (Const True) g
                          | otherwise = mkWBUntil b f g
simple3 (WBRelease b f g) | isDual f g = mkConst True
                          | otherwise = mkWBRelease b f g
simple3 f = f
-}
simple3 = id

-- Negation
simple4 (Negate f) = dual f
simple4 f = f

-- temporal nesting with equal subformulas
{-
simple5 x = case x of
  (f `Until` (g `Until` h)) -> if f == h || f == g then (g `mkUntil` h) else x
  ((f `Until` g) `Until` h) -> if f == h then (g `mkUntil` f) else
                               if g == h then (f `mkUntil` g) else x
  (BUntil b0 f (BUntil b1 g h)) -> if f == h || f == g then (BUntil (b0+b1) g h) else x
  (BUntil b0 (BUntil b1 f g) h) -> if f == h then (BUntil b0 g f) else
                                   if g == h then (BUntil b1 f g) else x
  -- TODO weak version
  (f `Release` (g `Release` h)) -> if f == h then (h `mkRelease` g) else
                                   if f == g then (g `mkRelease` h) else x
  ((f `Release` g) `Release` h) -> if f == h || g == h then (f `mkRelease` g) else x
  -- TODO bounded version
  -- TODO weak version
  _ -> x
-}
simple5 = id
--balance (And (And f g) h) = 
-- TODO: flatten it into a list (use list-monad), elimiate duplicate subformulas,
-- check for contradictions and rebuild a balanced tree.

-- TODO: add more simplification rules in a more systematic way.

-------------------------------------------------------------------------------
-- Unfold temporal operators

{-
-- unfold top level operator
unfoldF f = unfoldF' unfoldF f

-- unfold f i steps
unfoldLevelF 0 f = f
unfoldLevelF i f = unfoldF' (unfoldLevelF (i-1)) f

-- recursively unfold all operators
unfoldAllF f = bottomUpRec unfoldF f

-- recursively unfold all bounded operators
unfoldBoundedF f = bottomUpRec (\x -> if isBounded x then unfoldF x else x) f

-- Fixpoint characterization
unfoldF' r (BUntil (0,0) f g) = g
unfoldF' r (BUntil (_,0) f g) = error "lower bound must not be greater than upper bound"
unfoldF' r (BUntil (0,u) f g) = g `mkOr` (f `mkAnd` (mkNext (r (mkBUntil (0,u-1) f g))))
unfoldF' r (BUntil (l,u) f g) = mkNext (mkBUntil (l-1,u-1) f g)

unfoldF' r (WBUntil (0,0) f g) = g 
unfoldF' r (WBUntil (_,0) f g) = error "lower bound must not be greater than upper bound"
unfoldF' r (WBUntil (0,u) f g) = g `mkOr` (f `mkAnd` (mkWNext (r (mkBUntil (0,u-1) f g))))
unfoldF' r (WBUntil (l,u) f g) = mkWNext (mkWBUntil (l-1,u-1) f g)

unfoldF' r (BRelease (0,0) f g) = g 
unfoldF' r (BRelease (_,0) f g) = error "lower bound must not be greater than upper bound"
unfoldF' r (BRelease (0,u) f g) = g `mkAnd` (f `mkOr` (mkNext (r (mkBRelease (0,u-1) f g))))
unfoldF' r (BRelease (l,u) f g) = mkNext (mkBRelease (l-1,u-1) f g)

unfoldF' r (WBRelease (0,0) f g) = g 
unfoldF' r (WBRelease (_,0) f g) = error "lower bound must not be greater than upper bound"
unfoldF' r (WBRelease (0,u) f g) = g `mkAnd` (f `mkOr` (mkWNext (r (mkWBRelease (0,u-1) f g))))
unfoldF' r (WBRelease (l,u) f g) = mkWNext (mkWBRelease (l-1,u-1) f g)

-- Causes a blowup in the formula (not in the ciruit!)
unfoldF' r (Abort (BUntil (0,0) f g) e) = ((mkProp e) `mkOr` (g `mkAbort`e))
unfoldF' r (Abort (BUntil (_,0) f g) e) = error "lower bound must not be greater than upper bound"
unfoldF' r (Abort (BUntil (0,u) f g) e) = ((mkProp e) `mkOr` ((g `mkAbort`e) `mkOr` ((f `mkAbort`e) `mkAnd` (mkNext (r ((mkBUntil (0,u-1) f g) `mkAbort` e))))))
unfoldF' r (Abort (BUntil (l,u) f g) e) = ((mkProp e) `mkOr` mkNext (mkAbort (mkBUntil (l-1,u-1) f g) e)) 

unfoldF' r (Abort (WBUntil (0,0) f g) e) = ((mkProp e) `mkOr` (g `mkAbort`e))
unfoldF' r (Abort (WBUntil (_,0) f g) e) = error "lower bound must not be greater than upper bound"
unfoldF' r (Abort (WBUntil (0,u) f g) e) = ((mkProp e) `mkOr` ((g `mkAbort`e) `mkOr` ((f `mkAbort`e) `mkAnd` (mkWNext (r ((mkBUntil (0,u-1) f g) `mkAbort` e))))))
unfoldF' r (Abort (WBUntil (l,u) f g) e) = ((mkProp e) `mkOr` mkWNext (mkAbort (mkWBUntil (l-1,u-1) f g) e))

unfoldF' r (Abort (BRelease (0,0) f g) e) = ((mkProp e) `mkOr` (g `mkAbort`e))
unfoldF' r (Abort (BRelease (_,0) f g) e) = error "lower bound must not be greater than upper bound"
unfoldF' r (Abort (BRelease (0,u) f g) e) = ((mkProp e) `mkOr` ((g `mkAbort`e) `mkAnd` ((f `mkAbort`e) `mkOr` (mkNext (r ((mkBRelease (0,u-1) f g) `mkAbort` e))))))
unfoldF' r (Abort (BRelease (l,u) f g) e) = ((mkProp e) `mkOr` mkNext (mkAbort (mkBRelease (l-1,u-1) f g) e))

unfoldF' r (Abort (WBRelease (0,0) f g) e) = ((mkProp e) `mkOr` (g `mkAbort`e))
unfoldF' r (Abort (WBRelease (_,0) f g) e) = error "lower bound must not be greater than upper bound"
unfoldF' r (Abort (WBRelease (0,u) f g) e) = ((mkProp e) `mkOr` ((g `mkAbort`e) `mkAnd` ((f `mkAbort`e) `mkOr` (mkWNext (r ((mkWBRelease (0,u-1) f g) `mkAbort` e))))))
unfoldF' r (Abort (WBRelease (l,u) f g) e) = ((mkProp e) `mkOr` mkWNext (mkAbort (mkWBRelease (l-1,u-1) f g) e))

-- There is no unfolding for SImplies :-(
unfoldF' r f = f
-}
-------------------------------------------------------------------------------
-- PSL-Parser

formula :: (PSLFragment (reg prop), PSLFragment prop) => P.Parser (Formula reg prop)
formula = buildExpressionParser table prefixExpr
          P.<?> "PSL: formula"

atomicP :: (PSLFragment (reg prop), PSLFragment prop) => P.Parser (Formula reg prop)
atomicP = P.try (parser >>= return . mkWeakReg) 
          P.<|> (reservedOp "\\strong" >> parser >>= return . mkStrongReg)
          P.<|> parens formula
          P.<?> "PSL: atomic expression"

-- Note: all prefix operator have highest precedence
-- buildExpressionParser does not allow for nesting of prefixes of same precedence.
-- Moreover it seems that nesting of lower precedence prefix operators in higher precedence
-- prefix operators does not work as well.  Seems that I do not understand something there ...
prefixExpr :: (PSLFragment (reg prop), PSLFragment prop) => P.Parser (Formula reg prop)
prefixExpr = P.try atomicP
             P.<|> prefix "\\not" mkNegate
             P.<|> pPrefix "\\BN" mkBNext
             P.<|> pPrefix "\\wBN" mkWBNext
             P.<|> prefix "\\N" mkNext
             P.<|> prefix "\\wN" mkWNext
             P.<|> pPrefix "\\BG" mkBGlobally
             P.<|> pPrefix "\\BF" mkBEventually
             P.<|> pPrefix "\\sBG" mkSBGlobally
             P.<|> pPrefix "\\wBF" mkWBEventually
             P.<|> prefix "\\G" mkGlobally
             P.<|> prefix "\\F" mkEventually
             P.<?> "PSL: prefix expression"
             where
             prefix name fun  = (reservedOp name >> prefixExpr >>= return . fun)
             pPrefix name fun = (reservedOp name >> do { b <- bound ; f <- prefixExpr ; return (fun b f) })

table :: (PSLFragment (reg prop), PSLFragment prop) => [[Operator Char () (Formula reg prop)]]
table = [ [binary "\\and" mkAnd AssocLeft]
        , [binary "\\or" mkOr AssocLeft]
        , [binary "\\implies" mkImplies AssocRight]
        , [binary "\\equiv" mkEquiv AssocLeft]

        , [pBinary "\\BU" mkBUntil AssocRight, pBinary "\\BR" mkBRelease AssocLeft]
        , [pBinary "\\BW" mkBWaitfor AssocRight, pBinary "\\sBR" mkSBRelease AssocLeft]
        , [binary "\\U" mkUntil AssocRight, binary "\\R" mkRelease AssocLeft]
        , [binary "\\W" mkWaitfor AssocRight, binary "\\sR" mkSRelease AssocLeft]

        , [abort]
        , [simplies]
        ]

-- TODO: better move simplies to pslexpr
binary name fun assoc  = Infix (reservedOp name >> return fun) assoc
pBinary name fun assoc = Infix (reservedOp name >> bound >>= return . fun) assoc
prefix name fun        = Prefix (reservedOp name >> return fun)
-- pPrefix name fun       = Prefix (reservedOp name >> bound >>= return . fun)
postfix name fun       = Postfix (reservedOp name >> return fun)

abort :: (PSLFragment (reg prop), PSLFragment prop) => Operator Char () (Formula reg prop)
abort                  = Postfix (reservedOp "\\abort" >> parser >>= return . (flip mkAbort))

simplies :: (PSLFragment (reg prop), PSLFragment prop) => Operator Char () (Formula reg prop)
simplies               = Prefix  ( P.try $ do { x <- parser; reservedOp "\\simplies"; return (mkSImplies x)} )

-- bounds
-- bound :: P.GenParser Char st a
bound = boundExpr

boundExpr = buildExpressionParser boundTable boundTerm

boundTerm = (parens boundExpr) P.<|> (parseOrdinal)

boundTable :: OperatorTable Char () Ordinal
boundTable = [ [prefix "-" negate, prefix "+" id]
             , [postfix "++" (+1)]
             , [binary "*" (*) AssocLeft {-,  binary "/" (div) AssocLeft-} ]
             , [binary "+" (+) AssocLeft, binary "-" (-)   AssocLeft]
             ]


