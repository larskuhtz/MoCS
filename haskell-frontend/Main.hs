{- *** MOCS-COPYRIGHT-NOTICE-BEGIN ***
 -
 - This copyright notice is auto-generated by ./add-copyright-notice.
 - Additional copyright notices must be added below the last line of this notice.
 -
 - MoCS (https://lewis.cs.uni-saarland.de/tools/mocs/): "haskell-frontend/Main.hs".
 - The content of this file is copyright of Saarland University -
 - Copyright (C) 2009 Saarland University, Reactive Systems Group, Lars Kuhtz.
 -
 - This file is part of MoCS (https://lewis.cs.uni-saarland.de/tools/mocs/).
 -
 - License: three-clause BSD style license.
 - The license text can be found in the file LICENSE.
 -
 - *** MOCS-COPYRIGHT-NOTICE-END *** -}

-- | Main MoCS module
module Main where

import Control.Monad

import Data.List
import Data.Maybe
import System.Console.GetOpt
import System ( getArgs )
import System.Exit ( exitSuccess )
import qualified Data.Map as M
import Foreign.C.Types
import IO

import PSL
import ToString
import PSLFragment
import T2Automaton
import Ordinal

import CExpr
import CAut

-- generated by make
import MoCSVersion

-- -------------------------------------------------------------------------- --
-- Program Options
data Options = Options { version :: Bool
                       , formula :: Maybe PSL  -- takes an input method 
                       , help :: Bool
                       , output :: String
                       }

options :: [OptDescr (Options -> Options)] 
options = [ Option ['V'] ["version"] (NoArg (\o -> o {version = True})) "show version number"
          , Option ['f'] ["formula"] (ReqArg (\s o -> o {formula = getFormula s}) "STRING") "formula string"
          , Option ['h'] ["help"] (NoArg (\o -> o {help = True})) "display help text"
          , Option ['o'] ["output"] (ReqArg (\s o -> o {output = s}) "STRING") "output file name"
          ]

defaultOpts :: Options
defaultOpts = Options 
  { version = False
  , formula = Nothing
  , help = False
  , output = "/dev/stdout"
  }

getOptions :: [String] -> IO Options
getOptions args = do 
  case getOpt RequireOrder options args of
    (o,[f],[])   -> x (foldl (flip id) defaultOpts o, Just f)
    (o,[],[])    -> x (foldl (flip id) defaultOpts o, Nothing)
    (_,(_:t),[]) -> error ("Unexpected parameters: " ++ concat t ++ "\n" ++ commandLineHelp)
    (_,_,errs)   -> error (concat errs ++ commandLineHelp)
    where
    x (o@(Options { formula = Just _ }), _ ) = return o
    x (o@(Options { formula = Nothing }) , Just f ) = do { x <- parseFormulaFile f; return $ o { formula = x } }
    x (o@(Options { formula = Nothing }) , Nothing ) = do { x <- getContents; return $ o { formula = getFormula x } } --error ("Either option '-f' or a parameter with a formula file must be givien\n" ++ commandLineHelp)
    parseFormulaFile f = readFile f >>= (return.getFormula)

getFormula s = either (error . show) Just (parsePSL s)

usageHeader = "\
\MoCS [--ouput FILE] FILE\n\
\MoCS [--output FILE] --formula STRING\n\
\MoCS [--output FILE]\n\
\MoCS --help\n\
\MoCS --version\n\n\
\The formula is provided either via the -f option or in a file.\n\
\By default the formula is read from stdin and the result is written to stdout."

name = "MoCS"
versionInfo = name ++ " (version " ++ mocsVersion ++ " revision " ++ mocsRevision ++ ")\n\n" ++
              "Copyright (C) 2010 Saarland University\n" ++
              "Author: Lars Kuhtz <kuhtz@cs.uni-sb.de>\n\n" ++
              "All rights reserved. Usage exclusively under the terms of the license\n\
              \available from: http://react.cs-uni-sb.de/tools/mocs/LICENSE\n\n" ++
              "There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A\n\
              \PARTICULAR PURPOSE."


syntaxHelp = "\
\Syntax for formulas:\n\
\\n\
\Formula ::= '(' Formula ')' | RegEx | '\\strong' Regex\n\
\          | PrefixOp Formula | BPrefixOp BoundExpr Formula\n\
\          | Formula BinaryOp Formula | Formula BBinaryOp BoundExpr Formula\n\
\          | Formula '\\abort' Prop | RegEx '\\simplies' Formula\n\
\\n\
\PrefixOp ::= '\\not' | '\\N' | '\\wN' | '\\G' | '\\F'\n\
\BPreifxOp ::= '\\BN' | '\\wBN' | '\\BG' | '\\BF' | '\\sBG' | '\\wBF' \n\
\\n\
\BinaryOp ::= '\\and' | '\\or' | '\\implies' | '\\equiv'\n\
\           | '\\U' | '\\W' | '\\R' | '\\sR'\n\
\BBinaryOp ::= '\\BU' | '\\BR' | '\\BW' | '\\SBR'\n\
\\n\
\Prop ::= '(' Prop ')' | Var | 'true' | 'false' | '-' Prop\n\
\       | Prop '+' Prop | Prop '^' Prop\n\
\\n\
\RegEx ::= '(' RegEx ')' | Prop | 'epsilon'\n\
\        | RegEx '&&' RegEx | RegEx '|' RegEx | RegEx ':' RegEx | RegEx ';' RegEx\n\
\        | RegEx '*' | RegEx '[' Ordinal ']'\n\
\\n\
\Var ::= \"[_a-zA-Z][_a-zA-Z0-9]*\"\n\
\\n\
\BoundExpr ::= '(' BoundExpr ')' | Ordinal\n\
\            | BoundExpr '*' BoundExpr | '-' BoundExpr | BoundExpr '++'\n\
\\n\
\Ordinal ::= [0-9]+ | 'infty'"

commandLineHelp = usageInfo usageHeader options ++ "\n\n" ++ syntaxHelp

-- -------------------------------------------------------------------------- --
-- main program
{--
 main = do
 -  x <- newAutCtx
 -  -  a0 <- propAut x [1,2]
 -  -  a1 <- constAut x True
 -  -  a2 <- propAut x [2,3]
 -  -  a3 <- andAut a0 a1
 -  -  a4 <- orAut a3 a2
 -  -  a5 <- dualAut a4
 -  -  a6 <- nextAut =<< gAut =<< (untilAut a4 a3)
 -  -  autToDot "test.dot" a6 "aut"
 -  -  print "done"
 -
--}


-- enable / disable debugging
d a = a 

main = do

  -- get arguments
  args <- getArgs
  opts <- getOptions args

  when (version opts) (putStrLn versionInfo >> exitSuccess)
  when (help opts) (putStrLn commandLineHelp >> exitSuccess)

  -- Parse Formula
  let f = fromJust $ formula opts
  --d putStrLn $ toString f
  --d putStrLn $ show $ horizon f

  -- Separate
  let (prefix,suffix) = separate f
  let hor = maximum $ map horizon suffix
  --d putSep
  --d putStrLn $ "prefix-formula:"
  --d putStrLn $ toString prefix

  ------------------------------------------------------------------------------
  -- Prefix Automaton
  (_,ptable,a) <- createAut prefix
  --d putStrLn $ "prefix-automaton (ptable):"
  --d putStrLn $ toString $ ptable

  -- autToDot "pre.dot" a "prefix-automaton"
  --sctx <- contextSize ctx
  --d putStrLn $ "size of prefix-automaton-context: " ++ (show sctx)

  -- Universal prefix automaton
  --d putStrLn $ "universal prefix-automaton:"
  (_,b) <- universalAut a
  -- autToDot "preu.dot" b "universal prefix-automaton"
  --suctx <- contextSize uctx
  --d putStrLn $ "size of universal prefix-automaton-context: " ++ (show suctx)

  -- Build state machine
  -- sm <- mkStateMachine b
  -- smToDot "sm.dot" sm "state machine"

  -- rollout
  --d putStrLn $ "rollout " ++ (show hor) ++ " steps:"
  e <- autPrefixRollout (fromInteger $ finite $ hor) b
  -- putStrLn $ "get size of rollout context"
  --se <- getExprCtx e >>= contextSize
  --d putStrLn $ "size of rollout-context: " ++ (show $ se)

  ------------------------------------------------------------------------------
  -- Suffix Automata
  -- putSep
  --d putStrLn $ "number of suffixes: " ++ show (length suffix)
  tmpctx <- newAutCtx
  (_,stable,as) <- foldM doSuffix (tmpctx,M.empty,[]) (zip [0..] suffix)
  oexprs <- mapM (rollmap hor) as

  -- exprsToDot "suffix_exprs.dot" (concatMap snd oexprs) "suffix_expressions"

  -- oexprs is a map from suffix-formulas (toString as used in variables names of prefix)
  -- to its oexprs list

  -- print "build vhdl monitor"

  callVhdlBuildMonitor (output opts) (fromInteger $ finite $ hor) b ptable e oexprs stable

  -- print "done"
  --  putStrLn $ concat (parMap rnf doSuffix' suffix)


  where
  rollmap h (i,a) = do
    exprs <- autSuffixRollout (fromInteger $ finite $ h) a
    return (i,exprs)

doSuffix (ctx,table,as) (_,s) = do
  (nctx,ntable,sa) <- createAutWithCtxAndTable ctx table s
  --  putStrLn $ toString sa
  -- putStrLn $ A.stats sa
  -- autToDot ("suf" ++ show i ++ ".dot") sa ("suffix-automaton " ++ toString s)
  --bracket (openFile ("suf" ++ show i) WriteMode) hClose (\h -> A.doA2dot h $ mkInt sa)
  -- putSep
  return (nctx,ntable,as ++ [(toString s,sa)]) -- what does ntable look like?

putSep = putStrLn $ "--------------------"

callVhdlBuildMonitor :: String -> Int -> AutPtr -> PropTable -> ExprPtr -> [(String,[ExprPtr])] -> PropTable -> IO ()
callVhdlBuildMonitor
  fname -- filename
  hor    -- horizon
  prefix_automaton
  ptable -- variable index tabel for prefix automaton
  pa_expr -- output expression of prefix automaton
  suffix_expressions -- map from suffix formulae (variable name) to list of output expressions
  stable -- variable index tabel for suffix automata
  = do
    vhdlBuildMonitor fname hor (M.size stable) (M.size ptable) pa_expr prefix_automaton sexprs
    where
    sexprs :: [[ExprPtr]]
    sexprs =
      let
        swap (a,b) = (b,a)
        swap_sort_ptable :: [(CLong,String)]
        swap_sort_ptable = sortBy (comp) (map swap (M.toList ptable))
        comp a b = if a < b then LT else (if b < a then GT else EQ)
      in
        map (\(_,v) -> maybe (lookuperror v) id (lookup v suffix_expressions)) swap_sort_ptable

    lookuperror v = error $ "variable " ++ v ++ " in ptable but not in suffix expressions"

