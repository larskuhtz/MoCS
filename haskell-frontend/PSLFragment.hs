{- *** MOCS-COPYRIGHT-NOTICE-BEGIN ***
 -
 - This copyright notice is auto-generated by ./add-copyright-notice.
 - Additional copyright notices must be added below the last line of this notice.
 -
 - MoCS (https://lewis.cs.uni-saarland.de/tools/mocs/): "haskell-frontend/PSLFragment.hs".
 - The content of this file is copyright of Saarland University -
 - Copyright (C) 2009 Saarland University, Reactive Systems Group, Lars Kuhtz <kuhtz@cs.uni-sb.de>.
 -
 - This file is part of MoCS (https://lewis.cs.uni-saarland.de/tools/mocs/).
 -
 - License: three-clause BSD style license.
 - The license text can be found in the file LICENSE.
 -
 - *** MOCS-COPYRIGHT-NOTICE-END *** -}

module PSLFragment where

import Data.List
import Data.Either
import qualified Text.ParserCombinators.Parsec as Parsec
import ToString
import Ordinal

type Bound = Ordinal

type Horizon = Ordinal

fixpoint f a = if a == na then a else fixpoint f na
  where na = f a

-- minimal set of methods:
-- dual, horizon, parser, subf, subfmap, constant

class (Show a, ToString a, Eq a, Ord a) => PSLFragment a where

  dual :: a -> a
  isDual :: a -> a -> Bool
  isDual x y = (x == dual y)

  horizon :: a -> Horizon

  allSubf :: a -> [a]
  allSubf f = fixpoint (\x -> nub $ x ++ (concatMap subf x)) [f]
    -- Seems that this is principally not possibly with []-Monad because of order of nub and >>= (concatMap).
    -- Probably the nub should go inbetween concat and Map! We would need a list-monad with concatNubMap
    -- which would in fact be some kind of Set-Monad
    -- allSubf f = mfix (\x -> nub $ [f] ++ subf x)


  -- All Leaves (including duplicates)
  allLeaves :: a -> [a]
  allLeaves f = fixpoint (concatMap (\y -> if (subf y) == [] then [y] else subf y)) [f]

  parser :: Parsec.CharParser () a
  parse :: [Char] -> Either Parsec.ParseError a
  parse s = Parsec.parse parser "" s

  simplify :: a -> a
  simplify = id

  constant :: Bool -> a

  atomic :: a -> Bool
  atomic = null.subf

  constr :: a -> ([a] -> a)

  ------------------------------------------------------------------------------
  -- rather technical

  -- All (immediate) subformulas
  subf :: a -> [a]

  -- Apply first parameter to subformulas of second parameter
  -- Usefull for mutual recursive defintions (see e.g. pushNegations)
  subfmap :: (a -> a) -> a -> a

  bottomUpRec :: (a -> a) -> a -> a
  bottomUpRec o f = o $ subfmap (bottomUpRec o) f

  topDownRec :: (a -> a) -> a -> a
  topDownRec o f = subfmap (topDownRec o) (o f)

  topDownRecCond :: (a -> (Bool,a)) -> a -> a
  topDownRecCond o f = let (recurse,result) = (o f) in if recurse then subfmap (topDownRecCond o) result else result

