/* *** MOCS-COPYRIGHT-NOTICE-BEGIN ***
 *
 * This copyright notice is auto-generated by ./add-copyright-notice.
 * Additional copyright notices must be added below the last line of this notice.
 *
 * MoCS (https://lewis.cs.uni-saarland.de/tools/mocs/): "c-bindings/aa.h".
 * The content of this file is copyright of Saarland University -
 * Copyright (C) 2009 Saarland University, Reactive Systems Group, Lars Kuhtz <kuhtz@cs.uni-sb.de>.
 *
 * This file is part of MoCS (https://lewis.cs.uni-saarland.de/tools/mocs/).
 *
 * License: three-clause BSD style license.
 * The license text can be found in the file LICENSE.
 *
 * *** MOCS-COPYRIGHT-NOTICE-END *** */

#ifndef _AA_H_
#define _AA_H_

#include "context.h"
#include "expr.h"

#ifdef __cplusplus
extern "C" {
#endif

// incomplete. Pure pointer-interface.
struct automaton_t;
typedef struct automaton_t* automaton_ptr;

// constructors/ destructors
void free_automaton(automaton_ptr a);

// Get Context
context_ptr get_aut_context(automaton_ptr a);

// SImplies
// precondition: a is nondeterministic
automaton_ptr simplies_aut(const automaton_ptr a, const automaton_ptr b);

// Abort 
automaton_ptr abort_aut(const automaton_ptr a, const automaton_ptr b);

// Concatenation
// precondition: a is nondeterministic
automaton_ptr conc_aut(const automaton_ptr a, const automaton_ptr b);

// Overlapping Concatenation
// precondition: a is nondeterministic
automaton_ptr oconc_aut(const automaton_ptr a, const automaton_ptr b);

// Kleene-Closure
// precondition: a is nondeterministic
automaton_ptr kleene_aut(const automaton_ptr a);

// Union
automaton_ptr union_aut(const automaton_ptr a, const automaton_ptr b);

// Empty
automaton_ptr empty_aut(context_ptr c);

// Proposition
automaton_ptr prop_aut(context_ptr c, const c_prop_t p, int dim);

// Negated Proposition
automaton_ptr nprop_aut(context_ptr c, const c_prop_t p, int dim);

// Constant
automaton_ptr const_aut(context_ptr c, int p);

// Conjunction
automaton_ptr and_aut(const automaton_ptr a, const automaton_ptr b);

// Disjunction
automaton_ptr or_aut(const automaton_ptr a, const automaton_ptr b);

// Negation (dualization)
automaton_ptr dual_aut(const automaton_ptr a);

// Implication
automaton_ptr implies_aut(const automaton_ptr a, const automaton_ptr b);

// Next
automaton_ptr next_aut(const automaton_ptr a);
automaton_ptr bnext_aut(int i, const automaton_ptr a);

automaton_ptr wnext_aut(const automaton_ptr a);
automaton_ptr bwnext_aut(int i, const automaton_ptr a);

// Globally
automaton_ptr g_aut(const automaton_ptr a);
automaton_ptr bg_aut(int i, const automaton_ptr a);
automaton_ptr strong_bg_aut(int i, const automaton_ptr a);

// Eventually
automaton_ptr f_aut(const automaton_ptr a);
automaton_ptr bf_aut(int i, const automaton_ptr a);
automaton_ptr weak_bf_aut(int i, const automaton_ptr a);

// Until
automaton_ptr until_aut(const automaton_ptr a,const automaton_ptr b);
automaton_ptr buntil_aut(int i, const automaton_ptr a,const automaton_ptr b);

automaton_ptr waitfor_aut(const automaton_ptr a,const automaton_ptr b);
automaton_ptr bwaitfor_aut(int i, const automaton_ptr a,const automaton_ptr b);

// Release
automaton_ptr release_aut(const automaton_ptr a,const automaton_ptr b);
automaton_ptr brelease_aut(int i, const automaton_ptr a,const automaton_ptr b);

automaton_ptr strong_release_aut(const automaton_ptr a,const automaton_ptr b);
automaton_ptr strong_brelease_aut(int i, const automaton_ptr a,const automaton_ptr b);

// make weak
automaton_ptr weak_aut(const automaton_ptr a);

// Universalization
automaton_ptr universal_aut(const automaton_ptr a);

// Rollout
// returns null-terminated array of expression_ptr
expr_ptr* aut_suffix_rollout(const automaton_ptr a, int b);

// prefix-rollout (the expression is build within a new context)
expr_ptr aut_prefix_rollout(const automaton_ptr a, int b);

// TODO move this into vhdl.h
void vhdl_build_monitor(const char* file_name,
                        int b,
                        int pc,
                        int sc,
                        expr_ptr po,      // prefix automaton output expr
                        automaton_ptr pa, // prefix automaton
                        expr_ptr**);      // array of array of suffix output expr

// pretty-printing
void automaton2dot(const char* file_name, const automaton_ptr a, const char* name);

#ifdef __cplusplus
}
#endif

#endif // _AA_H_

