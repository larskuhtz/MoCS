/* *** MOCS-COPYRIGHT-NOTICE-BEGIN ***
 *
 * This copyright notice is auto-generated by ./add-copyright-notice.
 * Additional copyright notices must be added below the last line of this notice.
 *
 * MoCS (https://lewis.cs.uni-saarland.de/tools/mocs/): "libaaut/aa.tcc".
 * The content of this file is copyright of Saarland University -
 * Copyright (C) 2009 Saarland University, Reactive Systems Group, Lars Kuhtz <kuhtz@cs.uni-sb.de>.
 *
 * This file is part of MoCS (https://lewis.cs.uni-saarland.de/tools/mocs/).
 *
 * License: three-clause BSD style license.
 * The license text can be found in the file LICENSE.
 *
 * *** MOCS-COPYRIGHT-NOTICE-END *** */

#include <map>
#include <set>
#include <list>

#include "expr_util.hh"

namespace 
{
    struct aborter : expr::util::expr_rewriter
    {
        aborter(const automaton_t& b) : b(b), expr_rewriter() {}

        expr_t state_rec(const expr_t& x, state_t& new_state)
        {
            *new_state = rec(*x.state()) || *b.init;
            new_state.set_final(x.state().final());
            return c->mkState(new_state);
        }

        automaton_t b;
    };

    struct concer : expr::util::expr_rewriter
    {
        concer(const automaton_t& b) : b(b), lock(false), expr_rewriter() {}

        // precondition: argument is nondeterministic automaton!
        //               but no restriction on b!

        // if a state is reached:
        //   if final : suc' = suc || suc(b.init)
        //   for each state-less accepting disjunctiv branch b in suc:
        //     b' = b && state(b.init)
        //
        // When we travers suc of state s we do set a lock if we enter a
        // subbranch for which we already added state(b.init). I.e. if a
        // the algorithm is in locked state it only does recursive copy until
        // it enters a new state.

        expr_t state_rec(const expr_t& x, state_t& new_state)
        {
            bool uplock=lock;
            lock=false;

            if ( ! lock && expr::util::successor_states_count(x.state()) == 0) {
                lock=true;
                *new_state = rec(*x.state()) && c->mkState(b.init);
                lock=false;
            } else {
                *new_state = rec(*x.state());
            }

            if (x.state().final()) {
                *new_state = *new_state || *b.init;
                new_state.set_final(b.init.final());
            }

            lock=uplock;

            return c->mkState(new_state);
        }

        expr_t or_rec(const expr_t& e)
        {
            expr_t left, right;
            
            if (! lock && e.left().op() != Or &&  expr::util::successor_states_count(e.left()) == 0) {
                lock=true;
                left = rec(e.left()) && c->mkState(b.init);
                lock=false;
            } else {
                left = rec(e.left());
            }
            
            if (! lock && e.right().op() != Or &&  expr::util::successor_states_count(e.right()) == 0) {
                lock=true;
                right = rec(e.right()) && c->mkState(b.init);
                lock=false;
            } else {
                right = rec(e.right());
            }

            return left || right;
        }

        // if we find conjunction we know that either we are locked or exactly one side is state-less.
        // We lock that stateless side, and Handle only the state-carrying side.
        expr_t and_rec(const expr_t& e)
        {
            expr_t left, right;
            
            if (! lock && e.left().op() != And &&  expr::util::successor_states_count(e.left()) == 0) {
                lock=true;
                left = rec(e.left()); // && c->mkState(b.init);
                lock=false;
            } else {
                left = rec(e.left());
            }
            
            if (! lock && e.right().op() != And &&  expr::util::successor_states_count(e.right()) == 0) {
                lock=true;
                right = rec(e.right()); // && c->mkState(b.init);
                lock=false;
            } else {
                right = rec(e.right());
            }

            return left && right;
        }

        automaton_t b;
        bool lock;
    };

    struct oconcer : expr::util::expr_rewriter
    {
        oconcer(const automaton_t& b) : b(b), lock(false), expr_rewriter() {}

        virtual expr_t operator()(const expr_t& e)
        {
            expr_t r = expr_rewriter::operator()(e);
            if (r.op() != State) {
                state_t s = state_map[e.state()];
                return c->mkState(s);
            } else {
                return r;
            }
        }

        virtual expr_t state_rec(const expr_t& x, state_t& new_state)
        {
            bool uplock=lock;
            lock=false;

            if ( ! lock && expr::util::successor_states_count(x.state()) == 0) {
                lock=true;
                *new_state = rec(*x.state()) && *b.init;
                lock=false;
            } else {
                *new_state = rec(*x.state());
            }

            lock=uplock;

            return cache_conv(x,new_state);
        }

        virtual expr_t cache_conv(const expr_t& x, const state_t& new_state)
        {
            if (x.state().final()) {
                (const_cast<state_t*>(&new_state))->set_final(b.init.final());
                return c->mkState(new_state) || *b.init;
            } else {
                return c->mkState(new_state);
            }
        }

        virtual expr_t or_rec(const expr_t& e)
        {
            expr_t left, right;
            
            if (! lock && e.left().op() != Or &&  expr::util::successor_states_count(e.left()) == 0) {
                lock=true;
                left = rec(e.left()) && *b.init;
                lock=false;
            } else {
                left = rec(e.left());
            }
            
            if (! lock && e.right().op() != Or &&  expr::util::successor_states_count(e.right()) == 0) {
                lock=true;
                right = rec(e.right()) && *b.init;
                lock=false;
            } else {
                right = rec(e.right());
            }

            return left || right;
        }

        // if we find conjunction we know that either we are locked or exactly one side is state-less.
        // We lock that stateless side, and Handle only the state-carrying side.
        expr_t and_rec(const expr_t& e)
        {
            expr_t left, right;
            
            if (! lock && e.left().op() != And &&  expr::util::successor_states_count(e.left()) == 0) {
                lock=true;
                left = rec(e.left()); // && c->mkState(b.init);
                lock=false;
            } else {
                left = rec(e.left());
            }
            
            if (! lock && e.right().op() != And &&  expr::util::successor_states_count(e.right()) == 0) {
                lock=true;
                right = rec(e.right()); // && c->mkState(b.init);
                lock=false;
            } else {
                right = rec(e.right());
            }

            return left && right;
        }

        automaton_t b;
        bool lock;
    };

    struct simplier : oconcer
    {
        simplier(const automaton_t& b) : oconcer(b) {}
        virtual expr_t cache_conv(const expr_t& x, const state_t& new_state)
        {
            if (x.state().final()) {
                return c->mkState(new_state) && *b.init;
            } else {
                return c->mkState(new_state);
            }
        }
    };

    struct kleener :  expr::util::expr_rewriter
    {
        kleener(const automaton_t& a) : a(a), lock(false), expr_rewriter() {}
        
        expr_t state_rec(const expr_t& x, state_t& new_state)
        {
            state_map_t::const_iterator r = state_map.find(a.init);
            state_t init = r->second;
            
            bool uplock=lock;
            lock=false;

            if ( ! lock && expr::util::successor_states_count(x.state()) == 0) {
                lock=true;
                *new_state = rec(*x.state()) && c->mkState(init);
                lock=false;
            } else {
                *new_state = rec(*x.state());
            }

            if (x.state().final()) {
                *new_state = *new_state || rec(*a.init);
                new_state.set_final(a.init.final());
            }

            lock=uplock;
            return c->mkState(new_state);
        }

        expr_t or_rec(const expr_t& e)
        {
            state_map_t::const_iterator r = state_map.find(a.init);
            state_t init = r->second;
            
            expr_t left, right;
            
            if (! lock && e.left().op() != Or &&  expr::util::successor_states_count(e.left()) == 0) {
                lock=true;
                left = rec(e.left()) && c->mkState(init);
                lock=false;
            } else {
                left = rec(e.left());
            }
            
            if (! lock && e.right().op() != Or &&  expr::util::successor_states_count(e.right()) == 0) {
                lock=true;
                right = rec(e.right()) && c->mkState(init);
                lock=false;
            } else {
                right = rec(e.right());
            }

            return left || right;
        }

        // if we find conjunction we know that either we are locked or exactly one side is state-less.
        // We lock that stateless side, and Handle only the state-carrying side.
        expr_t and_rec(const expr_t& e)
        {
            expr_t left, right;
            
            if (! lock && e.left().op() != And &&  expr::util::successor_states_count(e.left()) == 0) {
                lock=true;
                left = rec(e.left()); // && c->mkState(b.init);
                lock=false;
            } else {
                left = rec(e.left());
            }
            
            if (! lock && e.right().op() != And &&  expr::util::successor_states_count(e.right()) == 0) {
                lock=true;
                right = rec(e.right()); // && c->mkState(b.init);
                lock=false;
            } else {
                right = rec(e.right());
            }

            return left && right;
        }

        automaton_t a;
        bool lock;
    };
}

inline automaton_t simplies_aut(const automaton_t& a, const automaton_t& b)
{
    expr_t tmp = a.init->efac()->mkState(a.init);
    expr_t n = simplier(b)(tmp);
    return oconc_aut(a,kleene_aut(const_aut(a.init->efac(),true))) >> automaton_t(n.state());
}

inline automaton_t abort_aut(const automaton_t& a, const automaton_t& b)
{
    expr_t tmp = a.init->efac()->mkState(a.init);
    expr_t n = aborter(b)(tmp);
    return automaton_t(n.state());
}

// concatenation a;b
// * for accepting states of a: suc' = suc || suc(b.init)
//   remove acceptance from a
// * dead-end states of a: suc' = suc && suc(b.init)
// NOTE: a is copied within the same context. b is used unchanged.
inline automaton_t conc_aut(const automaton_t& a, const automaton_t& b)
{
    expr_t tmp = a.init->efac()->mkState(a.init);
    expr_t n = concer(b)(tmp);
    return automaton_t(n.state());
}

inline automaton_t oconc_aut(const automaton_t& a, const automaton_t& b)
{
    expr_t tmp = a.init->efac()->mkState(a.init);
    expr_t n = oconcer(b)(tmp);
    return automaton_t(n.state());
}

// like concatenation but use suc(a.init) instead of suc(b.init). All accepting states
// of a remain accepting.
inline automaton_t kleene_aut(const automaton_t& a) 
{
    automaton_t b = a;
    if (! a.init.final()) {
        b = automaton_t(new_state(*a.init,true));
    }
    expr_t tmp = b.init->efac()->mkState(b.init);
    expr_t n = kleener(b)(tmp);
    return automaton_t(n.state());
}

inline automaton_t union_aut(const automaton_t& a, const automaton_t& b)
{
    return or_aut(a,b);
}

inline automaton_t empty_aut(efac_ptr c)
{
    return automaton_t(new_state(c->mkConst(false),true));
}

inline automaton_t prop_aut(efac_ptr c, const prop_t& p)
{
    return automaton_t(new_state(c->mkProp(p)));
}

inline automaton_t nprop_aut(efac_ptr c, const prop_t& p)
{
    return automaton_t(new_state(c->mkNProp(p),true));
}

inline automaton_t const_aut(efac_ptr c, bool p)
{
    return automaton_t(new_state(c->mkConst(p)));
}

inline automaton_t and_aut(const automaton_t& a, const automaton_t& b)
{
    if (a.init.final() && a.init->is_true()) { return b; }
    if (b.init.final() && b.init->is_true()) { return a; }
    return automaton_t(new_state(*a.init && *b.init,a.init.final() && b.init.final()));
}

inline automaton_t or_aut(const automaton_t& a, const automaton_t& b)
{
    return automaton_t(new_state(*a.init || *b.init,a.init.final() || b.init.final()));
}

// g
inline automaton_t g_aut(const automaton_t& a)
{
    state_t s = new_state(true);
    s.set_suc(*a.init && a.init->efac()->mkState(s));
    return automaton_t(s);
}

inline automaton_t g_aut(bound_t i, const automaton_t& a)
{
    if (i == 0) {
        return a;
    } else {
        return and_aut(a,wnext_aut(g_aut(i-1,a)));
    }
}

// strong g
inline automaton_t strong_g_aut(bound_t i, const automaton_t& a)
{
    if (i == 0) {
        return a;
    } else {
        return and_aut(a,next_aut(strong_g_aut(i-1,a)));
    }
}

// f
inline automaton_t f_aut(const automaton_t& a)
{
    state_t s = new_state();
    s.set_suc(*a.init || a.init->efac()->mkState(s));
    return automaton_t(s);
}

inline automaton_t f_aut(bound_t i, const automaton_t& a)
{
    if (i == 0) {
        return a;
    } else {
        return or_aut(a,next_aut(f_aut(i-1,a)));
    }
}

// weak f
inline automaton_t weak_f_aut(bound_t i, const automaton_t& a)
{
    if (i == 0) {
        return a;
    } else {
        return or_aut(a,wnext_aut(weak_f_aut(i-1,a)));
    }
}

// next
inline automaton_t next_aut(const automaton_t& a)
{
    state_t n = new_state(*a.init);
    return automaton_t(new_state(n->efac()->mkState(n)));
}

inline automaton_t next_aut(bound_t i, const automaton_t& a)
{
    if (i == 0) {
        return a;
    } else {
        return next_aut(next_aut(i-1,a));
    }
}

inline automaton_t wnext_aut(const automaton_t& a)
{
    state_t n = new_state(*a.init,true);
    return automaton_t(new_state(n->efac()->mkState(n),true));
}

inline automaton_t wnext_aut(bound_t i, const automaton_t& a)
{
    if (i == 0) {
        return a;
    } else {
        return wnext_aut(wnext_aut(i-1,a));
    }
}

// until
inline automaton_t until_aut(const automaton_t& a,const automaton_t& b)
{
    state_t s = new_state();
    s.set_suc(*b.init || (*a.init && a.init->efac()->mkState(s)));
    return automaton_t(s);
}

inline automaton_t until_aut(bound_t i, const automaton_t& a,const automaton_t& b)
{
    if (i == 0) {
        return b;
    } else {
        return or_aut(b,and_aut(a,next_aut(until_aut(i-1,a,b))));
    }
}

// waitfor
inline automaton_t waitfor_aut(const automaton_t& a,const automaton_t& b)
{
    state_t s = new_state(true);
    s.set_suc(*b.init || (*a.init && a.init->efac()->mkState(s)));
    return automaton_t(s);
}

inline automaton_t waitfor_aut(bound_t i, const automaton_t& a,const automaton_t& b)
{
    if (i == 0) {
        return b;
    } else {
        return or_aut(b,and_aut(a,wnext_aut(waitfor_aut(i-1,a,b))));
    }
}

// release
inline automaton_t release_aut(const automaton_t& a,const automaton_t& b)
{
    state_t s = new_state(true);
    s.set_suc(*b.init && (*a.init || a.init->efac()->mkState(s)));
    return automaton_t(s);
}

inline automaton_t release_aut(bound_t i, const automaton_t& a,const automaton_t& b)
{
    if (i == 0) {
        return b;
    } else {
        return and_aut(b,or_aut(a,wnext_aut(release_aut(i-1,a,b))));
    }
}

// strong release
inline automaton_t strong_release_aut(const automaton_t& a,const automaton_t& b)
{
    state_t s = new_state();
    s.set_suc(*b.init && (*a.init || a.init->efac()->mkState(s)));
    return automaton_t(s);
}

inline automaton_t strong_release_aut(bound_t i, const automaton_t& a,const automaton_t& b)
{
    if (i == 0) {
        return b;
    } else {
        return and_aut(b,or_aut(a,next_aut(strong_release_aut(i-1,a,b))));
    }
}

inline automaton_t dual_aut(const automaton_t& a)
{
    return automaton_t(new_state(expr::util::dual(*a.init), ! a.init.final()));
}

inline automaton_t weak_aut(const automaton_t& a)
{
    return automaton_t(expr::util::weak(a.init->efac()->mkState(a.init)).state());
}

namespace 
{

    typedef std::pair<expr_t,bound_t> lambda_cache_key_t;
    typedef std::pair<lambda_cache_key_t,expr_t> lambda_cache_value_t;

    std::size_t hash_value(const lambda_cache_key_t& k)
    {
        std::size_t s = 0;
        boost::hash_combine(s,k.first.uid());
        boost::hash_combine(s,k.second);
        return s;
    }

    struct lambda_cache_hasher
    {
        std::size_t operator()(const lambda_cache_key_t& k) const { return hash_value(k); }
    };

    typedef multi_index_container<
        lambda_cache_value_t,
        indexed_by<hashed_unique<member<lambda_cache_value_t,lambda_cache_key_t,&lambda_cache_value_t::first>,lambda_cache_hasher > >
    > lambda_cache_t;

    /* specialized rollauts
     * - uses new efac for all roll outs over the pipline --> becomes the resulting circuit
     * - uses new efac for all roll outs over (subf,pos) + state of prefix trans state machine
     */
    struct rollaut 
    {
        RUNTIME_ERROR(expr_type_error);

        expr_t state_rollout(const state_t& state)
        {
            return c->mkNProp(prop_t(1, (long) state.uid())) || lambda(*state,0);
        }

        struct state_rollout_dfs : public dfs
        {
            state_rollout_dfs(rollaut* context, expr_t& result) : context(context), result(result) {}
            void state_hook(const expr_t& e)
            {
                result = result && context->state_rollout(e.state());
            }
            rollaut* context;
            expr_t& result;
        };

        rollaut(const automaton_t& a, bound_t b) : 
            c(efac::newEfac()), 
            a(a), 
            b(b)
        {}

        // returns the list of all output gates of the circuit
        template<class T>
        efac_ptr operator()(std::back_insert_iterator<T> out)
        {
            for(bound_t i = 0; i <= b; ++i) {
                // std::cerr << "rollout: " << i;
                out = lambda(*a.init,i);
                // std::cerr << ", size: " << c->size() << std::endl;
            }
            return c;
        }

        // returns the (only) output gate of the circuit
        // inputs of the circuit are the propositions and
        // all states!
        //
        // During search of init put each encountered that into the list!
        //
        // NOTE: after rollout each input-prop is index by a vector of length two
        //       (namely (subf,h)). The special state input (from the ptsm) is
        //       indexed by the vector of length 1 namely (mem-addr-of-state).
        std::pair<expr_t,efac_ptr> operator()()
        {
            // rollout for each state. Result (NProp state_signal || rollout_for state)
            // Build conjunction over all rollouts
            expr_t result = state_rollout(a.init);
            state_rollout_dfs(this,result).run(a.init.suc());
            return std::make_pair(result,c);
        }

        lambda_cache_t cache;
        expr_t lambda(const expr_t& x, bound_t i)
        {
#define LAMBDA_CACHE
#ifdef LAMBDA_CACHE
            lambda_cache_t::const_iterator it = cache.find(std::make_pair(x,i));
            if ( it != cache.end() ) {
                return it->second;
            }
#endif
            expr_t ret;
            if (i == b) {
                switch (x.op()) {
                case And:   ret = lambda(x.left(),i) && lambda(x.right(),i); break; 
                case Or:    ret = lambda(x.left(),i) || lambda(x.right(),i); break;
                case Const: ret = c->copy(x); break;
                case Prop:  ret = c->mkProp(new_prop(x.prop(),i)); break;
                case NProp: ret = c->mkNProp(new_prop(x.nprop(),i)); break;
                case State: ret = x.state().final() ? c->mkTrue() : c->mkFalse(); break;
                }
            } else {
                switch (x.op()) {
                case And:   ret = lambda(x.left(),i) && lambda(x.right(),i); break; 
                case Or:    ret = lambda(x.left(),i) || lambda(x.right(),i); break;
                case Const: ret = c->copy(x); break;
                case Prop:  ret = c->mkProp(new_prop(x.prop(),i)); break;
                case NProp: ret = c->mkNProp(new_prop(x.nprop(),i)); break;
                case State: ret = lambda(*x.state(),i+1); break;
                }
            }
#ifdef LAMBDA_CACHE
            cache.insert(std::make_pair(std::make_pair(x,i),ret));
#endif
            return ret;
        }

        prop_t new_prop(const prop_t& p, bound_t i) const
        {
            // derive canonic and unique prop name from p an i
            prop_t n = p;
            n.push_back(i);
            return n;
        }

        efac_ptr c;
        automaton_t a;
        bound_t b;
    };
}; // anonymous


template<class T>
efac_ptr suffix_rollout(const automaton_t& a, 
                        bound_t b, 
                        std::back_insert_iterator<T> i)
{
    return rollaut(a,b)(i);
}

inline std::pair<expr_t,efac_ptr> prefix_rollout(const automaton_t& a, bound_t b)
{
    return rollaut(a,b)();
}

/* ************************************************************************** */
/* Universalization */

// cnf:
namespace {
#define main univ
#define neutral_accept false
#define DOP ||
#define OP &&
#define get_op expr::util::get_conj
#define get_dualop_states expr::util::get_disj_states
#define is_final has_final
#define split expr::util::split_disj
#define mkNF expr::util::mkCNF
#ifdef DEBUG_UNIV
#define DEBUG_SUBSET
#endif
#include "subsetconstruction.tcc"
#undef main
#undef neutral_accept
#undef DOP
#undef OP
#undef get_op 
#undef get_dualop_states
#undef is_final
#undef split
#undef mkNF
};

inline automaton_t universal_aut(const automaton_t& a)
{
    return ns_univ::univ(a);
}

/* ************************************************************************** */
/* Nondeterminization */

// dnf:
namespace {
#define main nondet
#define neutral_accept true
#define DOP &&
#define OP ||
#define get_op expr::util::get_disj
#define get_dualop_states expr::util::get_conj_states
#define is_final all_final
#define split expr::util::split_conj
#define mkNF expr::util::mkDNF
#ifdef DEBUG_NONDET
#define DEBUG_SUBSET
#endif
#include "subsetconstruction.tcc"
#undef main
#undef neutral_accept
#undef DOP
#undef OP
#undef get_op 
#undef get_dualop_states
#undef is_final
#undef split
#undef mkNF
};

inline automaton_t nondeterministic_aut(const automaton_t& a)
{
    return ns_nondet::nondet(a);
}


inline automaton_t operator&&(const automaton_t& a, const automaton_t& b)
{
    return and_aut(a,b);
}

inline automaton_t operator||(const automaton_t& a, const automaton_t& b)
{
    return or_aut(a,b);
}

inline automaton_t operator~(const automaton_t& a)
{
    return dual_aut(a);
}

inline automaton_t operator>>(const automaton_t& a, const automaton_t& b)
{
    return or_aut(~a,b);
}

inline automaton_t operator++(const automaton_t& a)
{
    return next_aut(a);
}

inline automaton_t operator*(bound_t i, const automaton_t& a)
{
    return g_aut(i,a);
}

inline automaton_t operator*(const automaton_t& a)
{
    return g_aut(a);
}

inline automaton_t operator+(bound_t i, const automaton_t& a)
{
    return f_aut(i,a);
}

inline automaton_t operator+(const automaton_t& a)
{
    return f_aut(a);
}

inline std::ostream& automaton2dot(std::ostream& o, const automaton_t& a, const std::string& name)
{
    expr_t tmp = a.init->efac()->mkState(a.init);
    return expr2dot(o,tmp,name);
}

