/* *** MOCS-COPYRIGHT-NOTICE-BEGIN ***
 *
 * This copyright notice is auto-generated by ./add-copyright-notice.
 * Additional copyright notices must be added below the last line of this notice.
 *
 * MoCS (https://lewis.cs.uni-saarland.de/tools/mocs/): "libaaut/expr.cc".
 * The content of this file is copyright of Saarland University -
 * Copyright (C) 2009 Saarland University, Reactive Systems Group, Lars Kuhtz.
 *
 * This file is part of MoCS (https://lewis.cs.uni-saarland.de/tools/mocs/).
 *
 * License: three-clause BSD style license.
 * The license text can be found in the file LICENSE.
 *
 * *** MOCS-COPYRIGHT-NOTICE-END *** */

#include <set>

#include "expr.hh"

std::ostream& operator<<(std::ostream& o, const expr_impl_t& e)
{
    switch (e.op) {
    case Const: return o << std::boolalpha << e.con;
    case Prop: return o << "p" << e.prop;
    case NProp: return o << "~" << "p" << e.prop;
    case State: return o << (long) e.state.uid();
    case And: return o << "(" << *e.left << " && " << *e.right << ")";
    case Or: return o << "(" << *e.left << " || " << *e.right << ")";
    default: return o << "error";
    }
}

std::ostream& operator<<(std::ostream& o, const expr_t& e)
{
    if (e == expr_t()) return o << "[??]";
    return o << *e.e;
}

template<op_t o>
expr_t expr_t::merge(const expr_t& r) const
{
    const expr_t& l = *this;
    // get set of conj/ disj for both sides
    std::set<expr_impl_ptr> s;
    get_ops<o>(l,std::inserter(s,s.begin()));
    get_ops<o>(r,std::inserter(s,s.begin()));
    // rebuild tree
    expr_impl_ptr tree = *s.begin();
    s.erase(s.begin());
    foreach(const expr_impl_ptr& e, s) {
        tree = ptr->check_hash(expr_impl_t(o,0,state_t(),prop_t(),ptr,tree,e));
    }
    return expr_t(tree,ptr);
}

expr_t expr_t::operator&& (expr_t r) const
{
    if (ptr != r.ptr) {
        std::runtime_error("context error");
    }
    if (*this == expr_t()) {
        return r;
    }
    if (r == expr_t()) {
        return *this;
    }
    if (is_true() || r.is_false() ) {
        return r;
    }
    if (is_false() || r.is_true()) {
        return *this;
    }
    if (r.e == e) {
        return *this;
    }
#if 0
    if (e < r.e) {
        return expr_t(ptr->check_hash(expr_impl_t(And,0,state_t(),prop_t(),ptr,e,r.e)),ptr);
    } else {
        return expr_t(ptr->check_hash(expr_impl_t(And,0,state_t(),prop_t(),ptr,r.e,e)),ptr);
    }
#endif
    return merge<And>(r);
}

expr_t expr_t::operator|| (expr_t r) const
{
    if (ptr != r.ptr) {
        std::runtime_error("context error");
    }
    if (*this == expr_t()) {
        return r;
    }
    if (r == expr_t()) {
        return *this;
    }
    if (is_true() || r.is_false() ) {
        return *this;
    }
    if (is_false() || r.is_true()) {
        return r;
    }
    if (r.e == e) {
        return *this;
    }
#if 0
    if (e < r.e) {
        return expr_t(ptr->check_hash(expr_impl_t(Or,0,state_t(),prop_t(),ptr,e,r.e)),ptr);
    } else {
        return expr_t(ptr->check_hash(expr_impl_t(Or,0,state_t(),prop_t(),ptr,r.e,e)),ptr);
    }
#endif
    return merge<Or>(r);
}

namespace
{

    struct expr2dot_dfs : public dfs
    {
        struct expr_less
        {
            bool operator()(const expr_t& a, const expr_t& b) { return a.uid() < b.uid(); }
        };

        typedef std::set<expr_t,expr_less> out_ports_t;

        std::ostream& o;
        out_ports_t out_ports;

        expr2dot_dfs(std::ostream& o) : o(o), out_ports(), dfs() {}

        template<class T>
        expr2dot_dfs(std::ostream& o, const T& p) : o(o), out_ports(p.begin(),p.end()), dfs() {}

        void init_hook(const expr_t& e) { out_ports.insert(e); }

        void node_hook(const expr_t& e) {
            std::string color = (out_ports.find(e) != out_ports.end()) ? "red" : "black";
            int peripheries = 2;
            switch (e.op()) {
            case And:  o << quote(e.uid()) << " " << branch_attr("*",color) << ";\n"; break;
            case Or:  o << quote(e.uid()) << " " <<  branch_attr("+",color) << ";\n"; break;
            case State: peripheries = e.state().final() ? 2 : 1;
            case Const:          
            case NProp:
            case Prop: o << quote(e.uid()) << " [label=" << quote(e) 
                                           << ", fontcolor=" << quote(color) 
                                           << ", peripheries=" << peripheries
                                           << "];\n"; break;
            default: o << "error\n";
            }
        }

        void edge_hook(const expr_t& s, const expr_t& t)
        {
            o << quote(s.uid()) << " -> " << quote(t.uid()) << ";\n";
        }

        std::string branch_attr(const std::string& l, const std::string& color) const
        {
            return "[label=" + quote(l) +  ", shape=plaintext, peripheries=0, height=0.2, width=0.2, fixedsize=true, fontcolor=" + quote(color) + "]";
        }
    };
};

std::ostream& expr2dot(std::ostream& o, const expr_t& e, const std::string& name)
{
    const char* q = "\"";
    o << "digraph " << quote(name) << " {\n";
    o << "node [peripheries=1];\n"; 
    expr2dot_dfs(o).run(e);
    o << "}" << std::endl;
}

std::ostream& exprs2dot(std::ostream& o, const std::list<expr_t>& l, const std::string& name)
{
    const char* q = "\"";
    o << "digraph " << quote(name) << " {\n";
    o << "node [peripheries=1];\n"; 
    expr2dot_dfs(o,l).run(l.begin(),l.end());
    int i = 0;
    foreach(const expr_t& x, l) {
        std::string n = "port_" + STRCAST(i);
        o << quote(n) << "[color=\"red\"];\n";
        o << quote(n) << " -> " << quote(x.uid()) << ";\n";
        ++i;
    }
    o << "}" << std::endl;
}

namespace
{

    std::string branch_attr(const std::string& l)
    {
        return "[label=" + quote(l) + ", shape=plaintext, peripheries=0, height=0.2, width=0.2, fixedsize=true]";
    }

    std::ostream& edge2dot(std::ostream& o, const expr_t& s, const expr_t& t)
    {
        return o << quote(s.uid()) << " -> " << quote(t.uid()) << ";\n";
    }

    std::ostream& gate2dot(std::ostream& o, const expr_t& e)
    {
        std::string color;
        int peripheries = 2;
        switch (e.op()) {
        case And: o << quote(e.uid()) << " " << branch_attr("*") << ";\n";
                  edge2dot(o,e,e.left());
                  edge2dot(o,e,e.right()); break;
        case Or: o << quote(e.uid()) << " " <<  branch_attr("+") << ";\n";
                 edge2dot(o,e,e.right());
                 edge2dot(o,e,e.left()); break;
        case State: peripheries = e.state().final() ? 2 : 1;
                    o << quote(e.uid()) << " [label=" << quote(e.state().uid()) << ", peripheries=" << peripheries << "];\n";
                    edge2dot(o,e,*e.state()); break;
        case Const:          
        case NProp:
        case Prop: o << quote(e.uid()) << " [label=" << quote(e) << ", peripheries=" << peripheries << "];\n"; break;
        default: o << "error\n";
        }
    }

};

std::ostream& efac2dot(std::ostream& o, const efac_ptr& c, const std::string& name)
{
    o << "digraph " << quote(name) << " {\n";
    o << "node [peripheries=1];\n"; 
    foreach(expr_impl_ptr x, c->cache)
    {
        gate2dot(o,expr_t(x,c));
    }
    o << "}" << std::endl;
}

