/* *** MOCS-COPYRIGHT-NOTICE-BEGIN ***
 *
 * This copyright notice is auto-generated by ./add-copyright-notice.
 * Additional copyright notices must be added below the last line of this notice.
 *
 * MoCS (https://lewis.cs.uni-saarland.de/tools/mocs/): "libaaut/expr.hh".
 * The content of this file is copyright of Saarland University -
 * Copyright (C) 2009 Saarland University, Reactive Systems Group, Lars Kuhtz.
 *
 * This file is part of MoCS (https://lewis.cs.uni-saarland.de/tools/mocs/).
 *
 * License: three-clause BSD style license.
 * The license text can be found in the file LICENSE.
 *
 * *** MOCS-COPYRIGHT-NOTICE-END *** */

#ifndef _EXPR_HH_
#define _EXPR_HH_

#include "config.h"
#include "util.hh"

#include <iostream>
#include <list>
#include <string>
#include <vector>

using boost::multi_index_container;
using namespace boost::multi_index;

/* ************************************************************************** */
/* state_t */

class expr_t;

// Note: the identity of state must not depend on the semantics of
// the label! Otherwise it would not be possibly to construct
// cyclic automata with expr caching because the hash of the state
// appears in the hash of an expr.
class state_impl_t;

class state_t
{
public:

    RUNTIME_ERROR(illegal_constructor_error);

    typedef boost::shared_ptr<state_impl_t> impl_ptr_t;

    state_t();
    state_t(const state_t& s);

    static state_t new_state(bool final = false);
    static state_t new_state(const expr_t& e, bool final = false);

    state_t& operator=(const state_t& s);

    const void* uid() const;
    const expr_t& suc() const;
    bool final() const;

    // syntactic sugar
    expr_t& operator*();
    const expr_t& operator*() const;
    expr_t* operator->();
    const expr_t* operator->() const;

    void set_suc(const expr_t& e);
    void set_final(bool f = true);

    bool operator==(const state_t& r) const;
    bool operator!=(const state_t& r) const;
    bool operator<(const state_t& r) const;

private:
    state_t(bool final);
    state_t(const expr_t& e, bool final);
    impl_ptr_t impl_ptr;
};

state_t new_state(bool final = false);
state_t new_state(const expr_t& e, bool final = false);


/* ************************************************************************** */
/* expr_t */

typedef std::vector<long> prop_t;

enum op_t { And, Or, Prop, NProp, State, Const };

std::size_t hash_value(const state_t& state);

class expr_impl_t;
typedef boost::intrusive_ptr<const expr_impl_t> expr_impl_ptr;
void intrusive_ptr_add_ref(const expr_impl_t* e);
void intrusive_ptr_release(const expr_impl_t* e);

class efac;
typedef boost::shared_ptr<efac> efac_ptr;
typedef boost::weak_ptr<efac> weak_efac_ptr;
typedef efac* raw_efac_ptr;

class expr_t
{
    friend class dfs;
    friend class efac;
    friend std::ostream& operator<<(std::ostream& o, const expr_t& e);
    friend std::ostream& rec_expr2dot(std::ostream& o, const expr_t& e);
    friend std::ostream& efac2dot(std::ostream& o, const efac_ptr& c, const std::string& name);

public:

    expr_t operator&& (expr_t r) const;
    expr_t operator|| (expr_t r) const;
    bool is_false() const;
    bool is_true() const;

    expr_t& operator=(const expr_t& r);
    bool operator==(const expr_t& r) const;
    
    expr_t();
    efac_ptr efac() const;
    std::list<expr_t> childs() const;

    // a unique identifier for the underlying expr, s.t.
    // expr == expr -> expr.uid == expr.uid
    // (e.g. usefull for output)
    const void* uid() const;

    op_t op() const;
    expr_t left() const;
    expr_t right() const;
    prop_t prop() const;
    prop_t nprop() const;
    state_t state() const;
    bool con() const;

    std::size_t size() const;

#ifdef DEBUG
    expr_impl_ptr impl() const;
#endif 

protected:
    
    template<op_t o, class T> static void get_ops(const expr_t& e, std::insert_iterator<T> out);
    template<op_t o> expr_t merge(const expr_t& r) const;

    expr_t(const expr_impl_ptr e, const efac_ptr&);
    expr_t(const expr_impl_ptr e, const weak_efac_ptr&);
    expr_impl_ptr e;
    efac_ptr ptr;
}; // expr_t

template<class T>
std::size_t size(const T& exprs);

/* ************************************************************************** */
/* efac */

class efac
{
    typedef const expr_impl_t* expr_impl_wptr;
    typedef multi_index_container<
        expr_impl_wptr,
        indexed_by<hashed_unique<identity<const expr_impl_t> > >
    > expr_impl_hash_t;

    friend std::ostream& efac2dot(std::ostream& o, const efac_ptr& c, const std::string& name);
    friend class expr_t;
    friend void intrusive_ptr_release(const expr_impl_t* e);

public:

    static boost::shared_ptr<efac> newEfac();
    static boost::shared_ptr<efac> newEfac(unsigned int n);

    // copy expr from a different efac
    expr_t copy(const expr_t& e);

    expr_t mkProp(prop_t p);
    expr_t mkNProp(prop_t p);
    expr_t mkState(const state_t& state);
    expr_t mkConst(bool b);
    expr_t mkTrue();
    expr_t mkFalse();

    std::size_t size() const;

#ifdef EFAC_HASH_INTERFACE
    std::size_t bucket_count() const;
    float load_factor() const;
    float max_load_factor() const;
    void max_load_factor(float z);
    void rehash(unsigned int n);
    std::size_t max_buck() const;
#endif

private:

    efac();
    efac(unsigned int n);

    expr_impl_hash_t cache;
    boost::weak_ptr<efac> ptr;
    const expr_impl_ptr check_hash(const expr_impl_t& expr);
}; // efac


/* ************************************************************************** */
/* dfs */

class dfs
{
public:
    dfs() : hash() {}
    void run(const expr_t& x);
    template<class I> void run(I a, I e);

protected:
    virtual ~dfs() {}
    
    virtual void pre_hook() {}
    virtual void post_hook() {}
    virtual void init_hook(const expr_t& x) {}
    virtual void node_hook(const expr_t& x) {}
    virtual void and_hook(const expr_t& x) {}
    virtual void or_hook(const expr_t& x) {}
    virtual void state_hook(const expr_t& x) {}
    virtual void const_hook(const expr_t& x) {}
    virtual void prop_hook(const expr_t& x) {}
    virtual void nprop_hook(const expr_t& x) {}
    virtual void edge_hook(const expr_t& s, const expr_t& t) {}

private:
    struct expr_uid_hasher
    {
        boost::hash<const void*> hasher;
        std::size_t operator()(const expr_t& e) const { return hasher(e.uid()); }
    };

    typedef multi_index_container<
        expr_t,
        indexed_by<hashed_unique<identity<expr_t>,expr_uid_hasher > >
    > expr_hash_t;

    void rec(const expr_t& x);

    expr_hash_t hash;
};

/* ************************************************************************** */
/* printing */

std::ostream& operator<<(std::ostream& o, const expr_t& e);
std::ostream& expr2dot(std::ostream& o, const expr_t& e, const std::string& name = "expr");
std::ostream& exprs2dot(std::ostream& o, const std::list<expr_t>& l, const std::string& name = "exprs");
std::ostream& efac2dot(std::ostream& o, const efac_ptr& c, const std::string& name = "efac");

#include "expr.tcc"

#endif // _EXPR_HH_
