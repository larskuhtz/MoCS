/* *** MOCS-COPYRIGHT-NOTICE-BEGIN ***
 *
 * This copyright notice is auto-generated by ./add-copyright-notice.
 * Additional copyright notices must be added below the last line of this notice.
 *
 * MoCS (https://lewis.cs.uni-saarland.de/tools/mocs/): "libaaut/util.hh".
 * The content of this file is copyright of Saarland University -
 * Copyright (C) 2009 Saarland University, Reactive Systems Group, Lars Kuhtz <kuhtz@cs.uni-sb.de>.
 *
 * This file is part of MoCS (https://lewis.cs.uni-saarland.de/tools/mocs/).
 *
 * License: three-clause BSD style license.
 * The license text can be found in the file LICENSE.
 *
 * *** MOCS-COPYRIGHT-NOTICE-END *** */

#ifndef _UTIL_HXX_
#define _UTIL_HXX_

#include "config.h"

#ifdef CHECK_ASSERTIONS
// define NDEBUG before including assert.h in order to disable asseration checking
#include <cassert>
#include <assert.h>
//#else
//#define NDEBUG
//#include <assert.h>
#endif

#include <cstdlib>
#include <stdexcept>
#include <string>
#include <vector>

#include <boost/smart_ptr.hpp>
#include <boost/lexical_cast.hpp>

#include <boost/foreach.hpp>
#define foreach BOOST_FOREACH

#define STRCAST(x) boost::lexical_cast<std::string>(x)

/** \name Macro to simplify definition of standard runtime errors
 */
#define RUNTIME_ERROR(x) struct x : public std::runtime_error { explicit x (const std::string& what = "") : std::runtime_error(what) {}; };

#define RUNTIME_ERROR2(x,y) struct x : public y { explicit x (const std::string& what = "") : y(what) {}; };

// Make sure to set NDEBUG as long as performance does not matter!
#if !defined(NDEBUG)
#define BOOST_MULTI_INDEX_ENABLE_INVARIANT_CHECKING
#define BOOST_MULTI_INDEX_ENABLE_SAFE_MODE
#endif

#include <boost/multi_index_container.hpp>
#include <boost/multi_index/identity.hpp>
#include <boost/multi_index/hashed_index.hpp>
#include <boost/multi_index/member.hpp>
#include <boost/multi_index/mem_fun.hpp>

#ifdef CHECK_ASSERTIONS
#define ASSERT(x) assert(x)
#else 
#define ASSERT(x) ""
#endif

/* ************************************************************************** */
/* quoting */
namespace
{
    template<class T>
    struct quote_t
    {
        const T& x;
        quote_t(const T& x) : x(x) {}
    };
};

template<class T>
inline quote_t<T> quote(const T& x)
{
    return quote_t<T>(x);
}

template<class T>
std::ostream& operator<<(std::ostream& o, const quote_t<T>& q)
{
    return o << "\"" << q.x << "\"";
}

inline std::string quote(const std::string& s)
{
    return "\"" + s + "\"";
}
/* ************************************************************************** */
/* listing */

#include <boost/function.hpp>

namespace
{
   template<class T>
   struct list_format_t
   {
       typedef boost::function<std::string (const typename T::value_type&)> formator_t;
       const T& x;
       const std::string& s;
       formator_t f;
       list_format_t(const std::string& s, const T& x, formator_t f) : x(x),s(s),f(f) {}
       list_format_t(const std::string& s, const T& x) : x(x),s(s),f() {}
   };
}

template<class T>
inline list_format_t<T> list_format(const std::string& s, const T& x, 
                                    const typename list_format_t<T>::formator_t& f)
{
    return list_format_t<T>(s,x,f);
}

template<class T>
inline list_format_t<T> list_format(const std::string& s, const T& x)
{
    return list_format_t<T>(s,x);
}

template<class T>
std::ostream& operator<<(std::ostream& o, const list_format_t<T>& l)
{
    typename T::const_iterator it = l.x.begin();
    if (it == l.x.end()) return o;
    if ( ! l.f ) {
        o << *it;
        for (++it; it != l.x.end(); ++it)
        {
            o << l.s << *it;
        }
    } else {
        o << l.f(*it);
        for (++it; it != l.x.end(); ++it)
        {
            o << l.s << l.f(*it);
        }
    }
    return o;
}

/* ************************************************************************** */

inline std::ostream& operator<<(std::ostream& o, const std::vector<long>& p)
{
    return o << "<" << list_format(",",p) << ">";
}

#endif

