/* *** MOCS-COPYRIGHT-NOTICE-BEGIN ***
 *
 * This copyright notice is auto-generated by ./add-copyright-notice.
 * Additional copyright notices must be added below the last line of this notice.
 *
 * MoCS (https://lewis.cs.uni-saarland.de/tools/mocs/): "libaaut/aa.hh".
 * The content of this file is copyright of Saarland University -
 * Copyright (C) 2009 Saarland University, Reactive Systems Group, Lars Kuhtz <kuhtz@cs.uni-sb.de>.
 *
 * This file is part of MoCS (https://lewis.cs.uni-saarland.de/tools/mocs/).
 *
 * License: three-clause BSD style license.
 * The license text can be found in the file LICENSE.
 *
 * *** MOCS-COPYRIGHT-NOTICE-END *** */

#ifndef _AA_HH_
#define _AA_HH_

#include "config.h"

#include <iostream>
#include <set>

#include "util.hh"
#include "expr.hh"

struct automaton_t {
    automaton_t(const efac_ptr& c) : init(new_state(c->mkConst(false))) {}
    automaton_t(const state_t& s) : init(s) {}
    state_t init;
};

typedef unsigned int bound_t;

/* ************************************************************************** */
/* SEREs */

// TODO implement test if an automaton is nondeterministic

// precondition: a is a nondeterministic automaton!!! 
automaton_t conc_aut(const automaton_t& a, const automaton_t& b);
automaton_t oconc_aut(const automaton_t& a, const automaton_t& b);

// same as or_aut
automaton_t union_aut(const automaton_t& a, const automaton_t& b);

// requires synchronization of accepting states
// Hardware/ statemachine: aditionally to input-or use input-and-gate, but
// only for acceptance. Requires duplication of accepting states - for
// "normal/ transitional/ non-accepting" use and acceptance. Synchronization
// propagates through existential branches. Within SEREs all universal branches
// synchronize.
// How do we extend the automaton model for this purpose. Can we do it
// only by local annotations on the states? May be introducing "collecting" states
// that are interpreted "backward", i.e. having a pre-relation that incodes the
// synchronization condition. This collecting state is then used as the accepting
// state of the intersection-automaton. The pre-transition is an epsilon transition!
//
// Implementation: we need determinization anyway. Hence, better don't use it!
//precondition: a and b are nondeterministic ??? do we need this ??
automaton_t intersection_aut(const automaton_t& a, const automaton_t& b);

automaton_t empty_aut(efac_ptr c);

//precondition: a is nondeterministic!!!
automaton_t kleene_aut(const automaton_t& a);


/* ************************************************************************** */

// SImplies
// precondition: a is nondeterministic!
automaton_t simplies_aut(const automaton_t& a, const automaton_t& b);

// Abort
automaton_t abort_aut(const automaton_t& a, const automaton_t& b);

// Proposition
automaton_t prop_aut(efac_ptr c, const prop_t& p);

// Negated Proposition
automaton_t nprop_aut(efac_ptr c, const prop_t& p);

// Constant
automaton_t const_aut(efac_ptr c, bool p);

// Conjunction
automaton_t operator&&(const automaton_t& a, const automaton_t& b);
automaton_t and_aut(const automaton_t& a, const automaton_t& b);

// Disjunction
automaton_t operator||(const automaton_t& a, const automaton_t& b);
automaton_t or_aut(const automaton_t& a, const automaton_t& b);

// Negation (dualization)
automaton_t operator~(const automaton_t& a);
automaton_t dual_aut(const automaton_t& a);

// Implication
automaton_t operator>>(const automaton_t& a, const automaton_t& b);

// Next
automaton_t operator++(const automaton_t& a);
automaton_t next_aut(const automaton_t& a); 
automaton_t next_aut(bound_t i, const automaton_t& a); 
automaton_t wnext_aut(const automaton_t& a);
automaton_t wnext_aut(bound_t i, const automaton_t& a);

// Globally
automaton_t operator*(const automaton_t& a);
automaton_t operator*(bound_t i, const automaton_t& a);
automaton_t g_aut(const automaton_t& a); 
automaton_t g_aut(bound_t i, const automaton_t& a);
automaton_t strong_g_aut(bound_t i, const automaton_t& a);

// Eventually
automaton_t operator+(const automaton_t& a);
automaton_t operator+(bound_t j, const automaton_t& a);
automaton_t f_aut(const automaton_t& a);
automaton_t f_aut(bound_t i, const automaton_t& a);
automaton_t weak_f_aut(bound_t i, const automaton_t& a);

// Until
automaton_t until_aut(const automaton_t& a,const automaton_t& b);
automaton_t until_aut(bound_t i, const automaton_t& a,const automaton_t& b);

// waitfor
automaton_t waitfor_aut(const automaton_t& a,const automaton_t& b);
automaton_t waitfor_aut(bound_t i, const automaton_t& a,const automaton_t& b);

// Release
automaton_t release_aut(const automaton_t& a,const automaton_t& b);
automaton_t release_aut(bound_t i, const automaton_t& a,const automaton_t& b);

// strong release
automaton_t strong_release_aut(const automaton_t& a,const automaton_t& b);
automaton_t strong_release_aut(bound_t i, const automaton_t& a,const automaton_t& b);

// abort
// a abort b: 
// foreach state of a: suc' = suc || b

// simplies:
// similar to concatenation of SEREs

// makeWeak
automaton_t weak_aut(const automaton_t& a);

// Universalization
automaton_t universal_aut(const automaton_t& a);

// Nondeterminization
automaton_t nondeterministic_aut(const automaton_t& a);

// Rollout
template<class T>
efac_ptr suffix_rollout(const automaton_t&, bound_t, std::back_insert_iterator<T>);
std::pair<expr_t,efac_ptr> prefix_rollout(const automaton_t& a, bound_t b);

// pretty-printing
std::ostream& automaton2dot(std::ostream& o, const automaton_t& a, const std::string& name = "automaton");

#include "aa.tcc"

#endif // _AA_HH_

