/* *** MOCS-COPYRIGHT-NOTICE-BEGIN ***
 *
 * This copyright notice is auto-generated by ./add-copyright-notice.
 * Additional copyright notices must be added below the last line of this notice.
 *
 * MoCS (https://lewis.cs.uni-saarland.de/tools/mocs/): "libaaut/subsetconstruction.tcc".
 * The content of this file is copyright of Saarland University -
 * Copyright (C) 2009 Saarland University, Reactive Systems Group, Lars Kuhtz <kuhtz@cs.uni-sb.de>.
 *
 * This file is part of MoCS (https://lewis.cs.uni-saarland.de/tools/mocs/).
 *
 * License: three-clause BSD style license.
 * The license text can be found in the file LICENSE.
 *
 * *** MOCS-COPYRIGHT-NOTICE-END *** */

/* ************************************************************************** */
/* Subset construction */

/* ************************************************************************** */
#if 0

// cnf:
#define main univ
#define neutral_accept false
#define DOP ||
#define OP &&
#define get_op expr::util::get_conj
#define get_dualop_states expr::util::get_disj_states
#define is_final has_final
#define mkNF expr::util::mkCNF
#difine split expr::util::split_disj
#ifdef DEBUG_UNIV
#define DEBUG_SUBSET
#endif

#endif

#define _NNAME(x) ns##_##x
#define NNAME(x) _NNAME(x)

namespace NNAME(main)
{
    RUNTIME_ERROR(expr_type_error);

    typedef std::set<state_t> state_set_t;
    typedef std::map< state_set_t, const state_t > map_t;

    state_t rec(const state_set_t& states, const efac_ptr& new_efac, map_t& map, const expr_t&, const efac_ptr& tmp_efac);
    expr_t mk_nf(const state_set_t& states, const efac_ptr& new_efac, map_t& map, const expr_t&, const efac_ptr& tmp_efac);
    bool has_final(const state_set_t& states);
    bool all_final(const state_set_t& states);

    using namespace expr::util;

    template<class T>
    struct static_cache 
    {
        typedef T value_t;
        typedef expr_t key_t;
        typedef EXPR_HASH_MAP(value_t) cache_t;
        cache_t cache;
        std::string name;

        static_cache(const std::string& name) : name(name) {}

        bool check(const key_t& k, value_t& result) const
        {
            typename cache_t::const_iterator it = cache.find(k);
            if (it != cache.end()) {
#ifdef DEBUG_SUBSET
                std::cerr << name << ": hit" << std::endl;
#endif
                result = it->second;
                return true;

            } else {
#ifdef DEBUG_SUBSET
                std::cerr << name << ": miss" << std::endl;
#endif
                return false;
            }
        }

        void update(const key_t& k, const value_t& v) { cache.insert(std::make_pair(k,v)); }
    };

    inline expr_t mkNF_wrapper(const expr_t& e, const efac_ptr& target_efac)
    {
#ifdef NF_WRAPPER_CACHE
        static static_cache<expr_t> cache("mkNF_wrapper_cache");
        { expr_t tmp; if (cache.check(e,tmp)) { return tmp; }}
#endif
        expr_t x = mkNF(e,target_efac);

#ifdef NF_WRAPPER_CACHE
        cache.update(e,x);
#endif
        return x;
    }

    std::pair<expr_t,expr_t> split_wrapper(const expr_t& d, const efac_ptr& tmp_efac, const efac_ptr& new_efac)
    {
#ifdef SPLIT_WRAPPER_CACHE
        static static_cache< std::pair<expr_t,expr_t> > cache("split_wrapper_cache");
        { std::pair<expr_t,expr_t> tmp; if (cache.check(d,tmp)) { return tmp; }}
#endif

        std::pair<expr_t,expr_t> x = split(d,tmp_efac,new_efac);
#ifdef SPLIT_WRAPPER_CACHE
        cache.update(d,x);
#endif
        return x;
    }

#ifdef SUBSET_GET_NEXT_STATE_EXPR_CACHE
    expr_t get_next_state_expr_wrapper(const expr_t& se, const efac_ptr& new_efac, map_t& map, const expr_t& efs, const efac_ptr& tmp_efac)
    {
        static static_cache<expr_t> cache("get_next_state_expr_wrapper_cache");
        { expr_t tmp; if (cache.check(se,tmp)) { return tmp; }}

        expr_t tmp;       
        using namespace std::rel_ops;
        if (se != expr_t()) {
            state_set_t states;
            expr::util::get_disj_states(se,std::inserter(states,states.begin()));
            state_t state = rec(states,new_efac,map,efs,tmp_efac);
            tmp = tmp || new_efac->mkState(state);
        }
        cache.update(se,tmp);
        return tmp;
    }
#endif

    automaton_t main(const automaton_t& a)
    {
        // 1. map.insert ({init},ninit)
        // 2. cur = {init}
        // 3. build cnf from suc of cur
        // 4. for each conj create new state (if any)
        //      create conj in new efac
        //      if (nstate not in map) {
        //        map.insert ({old-states},nstate)
        //        recurse on new state (or add it to queue)
        //  5. create suc of cur
        //

        // Experiment:
        // add disjunctive false state to each suc
        state_t fs = new_state(neutral_accept);
        fs.set_suc(a.init->efac()->mkState(fs));
        expr_t false_state_expr = a.init->efac()->mkState(fs);

        efac_ptr new_efac = efac::newEfac();
        efac_ptr tmp_efac = efac::newEfac();
        map_t map;
        state_set_t init_set;
        init_set.insert(a.init);
#ifndef DEBUG_SUBSET
        return automaton_t(rec(init_set,new_efac,map,false_state_expr,tmp_efac));
#else
        automaton_t ret(rec(init_set,new_efac,map,false_state_expr,tmp_efac));
        std::cerr << "exit univ" << std::endl;
        return ret;
#endif
    }

    inline bool has_final(const state_set_t& states)
    {
        foreach(const state_t& s, states) {
            if (s.final()) return true;
        }
        return false;
    }

    inline bool all_final(const state_set_t& states)
    {
        foreach(const state_t& s, states) {
            if (! s.final()) return false;
        }
        return true;
    }


    // Gets a set of states from old-efac and returns a state in new-efac
    // updates map with (states,new-state).
    state_t rec(const state_set_t& states, const efac_ptr& new_efac, map_t& map, const expr_t& efs, const efac_ptr& tmp_efac) 
    {
        map_t::const_iterator it = map.find(states);
        if (it != map.end()) return it->second;
#ifdef DEBUG_SUBSET
        static long count;
        count++;
        std::cerr << "count: " << count << ", states: " << states.size() << std::endl;
#endif

        // We insert the new state before computing its
        // suc, because during that computation we do the recursion.
        state_t state = new_state(is_final(states));
        map.insert(std::make_pair(states,state));

        // mk_cnf recurses (calls back into rec)
        state.set_suc(mk_nf(states,new_efac,map,efs,tmp_efac));
        
        return state;
    }

    // takes an expr within old-efac. Returns an cnf-expr within new-efac.
    // recurses on successor states
    expr_t mk_nf(const state_set_t& states, const efac_ptr& new_efac, map_t& map, const expr_t& efs, const efac_ptr& tmp_efac)
    {
        // build cnf
        expr_t common_suc = efs;
        foreach(const state_t& st, states) {
            common_suc = common_suc DOP mkNF_wrapper(*st,tmp_efac);
        }
        common_suc = mkNF_wrapper(common_suc,tmp_efac);

#ifdef SUC_EXPR_CACHE
        static static_cache<expr_t> suc_expr_cache("suc_expr_cache");
        { expr_t tmp; if (suc_expr_cache.check(common_suc,tmp)) { return tmp; }}
#endif

        // get conjuncts
        std::list<expr_t> l;
        get_op(common_suc, std::back_inserter(l));

        // merge states in each conjunct
        // i.e. split each conjunct into states and rest.
        // states remain into tmp_efac rest goes into new_efac
        expr_t root;
        foreach(const expr_t& d, l) {
            
#ifdef SUBSET_OP_CACHE
            static static_cache<expr_t> op_cache("conj_cache");
            {expr_t tmp; if (op_cache.check(d,tmp)) { root = root && tmp; continue; }}
#endif

            // split conjunct into state-disjunct and rest
            // rest is copied into new-efac on the fly
            // se remains in tmp-efac
            expr_t se, re;
            boost::tie(se,re) = split_wrapper(d,tmp_efac,new_efac);

            // se is a disjunction of states: get state_set from se
            // create new state in new-efac from it
            using namespace std::rel_ops;
#ifdef SUBSET_GET_NEXT_STATE_EXPR_CACHE
            expr_t tmp = get_next_state_expr_wrapper(se,new_efac,map,efs,tmp_efac);
#else
            expr_t tmp;       
            if (se != expr_t()) {
                state_set_t states;
                get_dualop_states(se,std::inserter(states,states.begin()));
                state_t state = rec(states,new_efac,map,efs,tmp_efac);
                tmp = tmp DOP new_efac->mkState(state);
            }
#endif
            if (re != expr_t()) {
                tmp = tmp DOP re;
            }
            assert( tmp != expr_t());

#ifdef CONJ_CACHE
            conj_cache.update(d,tmp);
#endif

            // join new state with rest and add it the root
            root = root OP tmp;
        }

#ifdef SUC_EXPR_CACHE
        suc_expr_cache.update(common_suc,root);
#endif
        return root;
    }
};

