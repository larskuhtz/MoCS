{- *** MOCS-COPYRIGHT-NOTICE-BEGIN ***
 -
 - This copyright notice is auto-generated by ./add-copyright-notice.
 - Additional copyright notices must be added below the last line of this notice.
 -
 - MoCS (https://lewis.cs.uni-saarland.de/tools/mocs/): "haskell-bindings/CExpr.hs".
 - The content of this file is copyright of Saarland University -
 - Copyright (C) 2009 Saarland University, Reactive Systems Group, Lars Kuhtz.
 -
 - This file is part of MoCS (https://lewis.cs.uni-saarland.de/tools/mocs/).
 -
 - License: three-clause BSD style license.
 - The license text can be found in the file LICENSE.
 -
 - *** MOCS-COPYRIGHT-NOTICE-END *** -}

{-# LANGUAGE ForeignFunctionInterface #-}
module CExpr where

import Foreign
import ForeignPtr
import Foreign.C.Types
import Foreign.C.String
import Foreign.Marshal.Array

-- -------------------------------------------------------------------------- --
-- Utils
int2c i = fromInteger $ toInteger i

-- Maybe we shall use the following:
-- nest :: [(r -> a) -> a] -> ([r] -> a) -> a
-- nest xs = runCont (sequence (map Cont xs))
-- or alternatively: nest = runCont . sequence . map Cont

withForeignPtr2 :: ForeignPtr a -> ForeignPtr b -> (Ptr a -> Ptr b -> IO c) -> IO c
withForeignPtr2 a b act = do
   let aptr = unsafeForeignPtrToPtr a
   let bptr = unsafeForeignPtrToPtr b
   ret <- act aptr bptr
   touchForeignPtr a
   touchForeignPtr b
   return ret

withForeignPtrList :: [ForeignPtr a] -> (Ptr (Ptr a) -> IO b) -> IO b
withForeignPtrList l act = do
   let x = map unsafeForeignPtrToPtr l
   arr <- newArray0 nullPtr x
   ret <- act arr
   mapM touchForeignPtr l
   free arr
   return ret

withForeignPtr2List :: [[ForeignPtr a]] -> (Ptr (Ptr (Ptr a)) -> IO b) -> IO b
withForeignPtr2List l act = do
   let x = map (map unsafeForeignPtrToPtr) l
   arr <- mapM (newArray0 nullPtr) x
   arr2 <- newArray0 nullPtr arr
   ret <- act arr2
   mapM (mapM touchForeignPtr) l
   mapM free arr
   free arr2
   return ret

-- -------------------------------------------------------------------------- --
-- Context
data CExprCtx = CExprCtx
foreign import ccall "context.h &free_context" free_context :: FunPtr (Ptr CExprCtx -> IO ())
foreign import ccall "context.h new_context" new_context :: IO (Ptr CExprCtx)
foreign import ccall "context.h context_size" context_size :: (Ptr CExprCtx) -> IO CInt

type ExprCtxPtr = ForeignPtr CExprCtx

mkExprCtx :: Ptr CExprCtx -> IO ExprCtxPtr
mkExprCtx = newForeignPtr free_context

newExprCtx :: IO ExprCtxPtr
newExprCtx = new_context >>= mkExprCtx

contextSize :: ExprCtxPtr -> IO Integer
contextSize p = withForeignPtr p context_size >>= return.toInteger

-- -------------------------------------------------------------------------- --
-- Expr
data CExpr = CExpr
foreign import ccall "expr.h &expr_free" expr_free :: FunPtr (Ptr CExpr -> IO ())

foreign import ccall "expr.h expr_and" expr_and :: (Ptr CExpr) -> (Ptr CExpr) -> IO (Ptr CExpr)
foreign import ccall "expr.h expr_or" expr_or :: (Ptr CExpr) -> (Ptr CExpr) -> IO (Ptr CExpr)
foreign import ccall "expr.h expr_expr2dot" expr_expr2dot :: CString -> (Ptr CExpr) -> CString -> IO ()
foreign import ccall "expr.h expr_exprs2dot_" expr_exprs2dot_ :: CString -> Ptr (Ptr CExpr) -> CString -> IO ()
foreign import ccall "expr.h expr_to_string" expr_to_string :: (Ptr CExpr) -> IO CString
foreign import ccall "expr.h expr_get_context" expr_get_context :: (Ptr CExpr) -> IO (Ptr CExprCtx)
foreign import ccall "expr.h expr_eq" expr_eq :: (Ptr CExpr) -> (Ptr CExpr) -> IO Bool
foreign import ccall "expr.h expr_is_false" expr_is_false :: (Ptr CExpr) -> IO Bool
foreign import ccall "expr.h expr_is_true" expr_is_true :: (Ptr CExpr) -> IO Bool
foreign import ccall "expr.h expr_size" expr_size :: (Ptr CExpr) -> IO CInt
foreign import ccall "expr.h exprs_size" exprs_size :: Ptr (Ptr CExpr) -> IO CInt

type ExprPtr = ForeignPtr CExpr

mkExprPtr :: Ptr CExpr -> IO ExprPtr
mkExprPtr = newForeignPtr expr_free

andExpr :: ExprPtr -> ExprPtr -> IO ExprPtr
andExpr a b = withForeignPtr2 a b expr_and >>= mkExprPtr

orExpr :: ExprPtr -> ExprPtr -> IO ExprPtr
orExpr a b = withForeignPtr2 a b expr_or >>= mkExprPtr

getExprCtx :: ExprPtr -> IO ExprCtxPtr
getExprCtx a = withForeignPtr a expr_get_context >>= mkExprCtx

exprToDot :: String -> ExprPtr -> String -> IO ()
exprToDot fname a name = do 
  f <- newCString fname
  n <- newCString name
  withForeignPtr a $ (\a -> expr_expr2dot f a n)
  free f
  free n

exprsToDot :: String -> [ExprPtr] -> String -> IO ()
exprsToDot fname a name = do 
  f <- newCString fname
  n <- newCString name
  withForeignPtrList a $ (\x -> expr_exprs2dot_ f x n)
  free f
  free n

exprToString :: ExprPtr -> IO String
exprToString e = do
  cstr <- withForeignPtr e expr_to_string
  str <- peekCString cstr
  free cstr
  return str

exprEq :: ExprPtr -> ExprPtr -> IO Bool
exprEq e0 e1 = withForeignPtr2 e0 e1 expr_eq

exprIsFalse :: ExprPtr -> IO Bool
exprIsFalse e = withForeignPtr e expr_is_false

exprIsTrue :: ExprPtr -> IO Bool
exprIsTrue e = withForeignPtr e expr_is_true

exprSize :: ExprPtr -> IO Integer
exprSize e = withForeignPtr e expr_size >>= return.toInteger

exprsSize :: [ExprPtr] -> IO Integer
exprsSize e = withForeignPtrList e exprs_size >>= return.toInteger

